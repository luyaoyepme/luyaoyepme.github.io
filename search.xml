<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML5补充知识点]]></title>
    <url>%2F2018%2F08%2F19%2Fhtml5_3_add%2F</url>
    <content type="text"><![CDATA[动画的优化requestAnimation概念window.requestAnimation()方法告诉浏览器，您希望执行动画并请求浏览器在下一次重绘之前调用指指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。 当你需要更新屏幕画面的时候就可以调用。在浏览器下次重绘之前执行回调函数，回调的次数通常是每秒60次但大多数浏览器通常匹配 W3C 所建议的刷新频率。在大多数浏览器里，当运行在后台标签页或者隐藏的&lt;iframme&gt;里时，requestAnimationFrame()会暂停调用以提升性能和电池寿命。 语法语法： 1window.requestAnimationFrame(callback); 封装： 12345678window.requestAnimationFrame = (function()&#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback)&#123; window.setTimeout(callback,1000/60); &#125; &#125;)() cancelAnimation概念取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求。 语法12window.cancelAnimationFrame(requestID);//requestID 是先前调用window.requestAnimationFrame()方法时返回的id 封装 12345678window.cancelAnimationFrame = (function()&#123; return window.CancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(id)&#123; window.clearTimeout(id); &#125; &#125;)() demo: 1234567891011121314151617181920212223242526272829window.requestAnimationFrame = (function()&#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback)&#123; window.setTimeout(callback,1000/60); &#125; &#125;)() window.cancelAnimationFrame = (function()&#123; return window.CancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(id)&#123; window.clearTimeout(id); &#125; &#125;)() //var timer; var req; function move()&#123; btn.style.left = btn.offsetLeft + 10 +'px'; if(btn.offsetLeft &gt;= 300)&#123; cancelAnimationFrame(req); btn.style.left = 300 +'px'; &#125;else&#123; req = requestAnimationFrame(move); &#125; &#125; move(); http://www.webhek.com/post/requestanimationframe.html 客户端存储localstorage、sessionstoragelocalStorage概念 localStorage是一种没有时间限制（永久存储）的数据存储，是HTML5引进的新特性，在h5之前，一直都是用cookie来存储数据的，而localStorage是存储在用户本地的浏览器上，不想cookie一样携带在http请求头部的字段里面，这样有效的节约了带宽。值得一提的是，localStorage同样也采用了同源策略对存储的容量进行了限制，一般限制为同一域名5M,不同域名的数据不能互相访问 语法123456789101112131415161718192021222324var mylocalStorage = window.localStorage; mylocalStorage.clear(); mylocalStorage.setItem('test-arry', [1, 2, 3, 4]) console.log('数组的值', mylocalStorage.getItem('test-arry')); //获取数组第一项 console.log('数组的第一项值', mylocalStorage.getItem('test-arry').split(',')[0]); var data = &#123; 'a': 1, 'b': 3 &#125; mylocalStorage.setItem('test-obj', data) console.log('直接存储对象', mylocalStorage.getItem('test-obj')); var dataStr = JSON.stringify(data); mylocalStorage.setItem('test-str', dataStr) console.log('转化后存储对象', mylocalStorage.getItem('test-str')); var data = JSON.parse(mylocalStorage.getItem('test-str')); console.log('重新解析对象', data); localStorage存储的只能是字符串的形式，当我们存储数据为引用对象的时候，会默认调用toString()方法，转化为字符串再进行存储，存储的数据项将会以逗号隔开，解析的时候需要我们分解成为数组在进行操作，对于对象，我们需要用JSON.stringfy转化存储，获取数据后再用JSON.parse转化为对象。 localStorage操作方法 方法名 含义 localStorage.length() 获取当前存储的键值对数量 localStorage.key(n) 获取第n项的键值 localStorage.setItem() 设置对应的键值对 localStorage.getItem() 获取对应键值的数据 localStorage.remove(key) 清除某个数据 localStorage.clear() 清除存储的所有数据 localStorage的适用范围 localStorage有5M的容量可以存储，所以可以存储一些不需要和服务器进行交互的数据。比如导航栏当前的状态，一些普通的数据进行缓存。甚至我们可以存储html、js或者css片段。由于现在手机端对localStorage的支持已经非常完善，有很多应用通过版本控制来存储一些不经常改动的js/css文件。减少用户请求带宽的同时，优化整个页面的加载速度。 如可以用来统计页面访问次数。 sessionstorage概念sessionStorage 是HTML5新增的一个会话存储对象，存储在本地浏览器上，用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。可以在js中调用该对象。存放数据一般在5M以下。 语法： 语法和localStorage一致，两者主要不同是存储时间和同源策略限制问题。复习时着重记住这两点 123456789101112131415161718192021222324var mysessionStorage = window.sessionStorage; mysessionStorage.clear(); mysessionStorage.setItem('test-arry', [1, 2, 3, 4]) console.log('数组的值', mysessionStorage.getItem('test-arry')); //获取数组第一项 console.log('数组的第一项值', mysessionStorage.getItem('test-arry').split(',')[0]); var data = &#123; 'a': 1, 'b': 3 &#125; mysessionStorage.setItem('test-obj', data) console.log('直接存储对象', mysessionStorage.getItem('test-obj')); var dataStr = JSON.stringify(data); mysessionStorage.setItem('test-str', dataStr) console.log('转化后存储对象', mysessionStorage.getItem('test-str')); var data = JSON.parse(mysessionStorage.getItem('test-str')); console.log('重新解析对象', data); sessionStorage操作方法 同localstorage一致，这里不再赘述。 sessionStorage适用范围适用于一些即时销毁的数据，因为当浏览器窗口关闭了，数据就不存在了。 可以用来统计当前页面下元素的访问次数。 同源策略的限制localstorage 受文档源限制 sessionstorage受文档源+窗口限制 不同的浏览器无法共享localStorage和sessionStorage中的信息，相同浏览器的不同页面可以共享相同的localStorage（页面属于相同的域名和端口），但是不同页面之间不能共享sessionstorage中的信息。这里需要注意的是，页面以及标签页仅仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。 如果存储了中文storage 则可以用 encodeURLComponent 编码 decodeURLComponent 解码 和cookie相比特性上的区别 cookie在服务器端和浏览器端来回传递数据（服务器生成，可设置失效时间；如果在浏览器端生成cookie，默认是关闭浏览器后失效）localStorage和sessionStorage不会自动把数据发送给服务器，仅仅保存在本地。cookie会在浏览器请求头或者ajax请求头中发送cookie内容 。 cookie的存放数据大小是4k左右，一个domain里最多能存放20条cookie，而storage则有5M的大小。 cookie可以设置过期日期，sessionStorage是会话级的数据，浏览器窗口关闭即清楚，localStorage是永久性的数据，一旦赋值，不管多长时间这值都是存在的，除非手动清除。 sessionStorage不跨窗口，在另外一个窗口打开sessionStorage就不存在了，它只在当前窗口有效，而cookie和localStorage都是跨窗口的，即使浏览器的窗口关闭，这两个值还是存在的。 使用场景上的区别 localStorage可以用来统计页面访问次数。 sessionStorage可以用来统计当前页面元素的点击次数。 cookie一般存储用户名密码相关信息，一般使用escape转义编码后存储。 cookie概念及语法navigator.cookieEnabled 检测是否启用了cookie 见前端网络修养章节笔记。 cookie的优点1.通过良好的编程，控制保存在cookie中的session对象的大小。2.通过加密和安全传输技术，减少cookie被破解的可能性。3.只有在cookie中存放不敏感的数据，即使被盗取也不会有很大的损失。4.控制cookie的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就 是一个过期的cookie。 cookie的缺点1.cookie的长度和数量的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB。否则会被截掉。2.安全性问题。如果cookie被人拦掉了，那个人就可以获取到所有session信息。加密的话也不起什么作用。3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务端保存一个计数器。若吧计数器保存在客户端，则起不到什么作用。 历史记录概念 window对象通过history对象提供了对浏览器历史的访问。它暴露了很多有用的方法和属性，允许你在用户浏览历史中向前和向后跳转，同时，从HTML5中提供了对了对history栈中内容的操作 history操作方法history.back() | history.forward()回退到上一个页面 |向前跳转 语法 12window.history.back();window.history.forward(); history.go(n) 跳转到指定的页面，参数n为负数时向前跳转，如当n=-1时向前跳转一个页面，当n=2时，向后跳转2个页面。 history.pushState()该方法是增添历史记录条目，但是不刷新页面，它和接下来要讲的replaceState方法在使用的时候都会和window.onpopstate配合使用 语法: 1history.pushState(state,title,url); 参数列表： 参数名 参数意义 state 一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数中。如果不需要这个对象，此处可以填null。 title： 新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。 url 新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。 从某种意义上，pushState与window.location=“#ff” 类似，二者都会在当前页面创建并激活新的历史记录。但pushState有一下几个优点： 新的URL可以是与当前URL同源的任何URL。而设置window.location 仅当你只修改了哈希值时才保持了同一个document。 如果需要，可以不改变URL，而设置window.location=”#ff”，在当前hash不是#ff的情况下，仅仅只是新建了一个新的历史记录选项 我们可以为新的历史记录选项关联任意数据。而基于hash值的方式，则必须将所有相关数据编码到一个端字符串里。 假如title参数将来会被浏览器用到，那么这个数据是可以被使用的，而哈希不可以 history.replaceState()替换当前的历史记录 ,但是不刷新页面.注意这并不会阻止其在全局浏览器历史记录中创建一个新的历史记录项。 假设一个html执行一个pushState方法，且url为‘bar1.html’ 然后再执行一个replaceState方法，url为‘bar2.html’ 那么浏览器地址栏最后显示的是bar2.html，但是浏览器不会去加载bar2，甚至不会去检查其是否存在。假设 语法： 1history.replaceState(state,title,url); history事件popstate历史记录改变时触发，调用history.pushState()或者history.replaceState()不会触发popstate事件 语法： 1234window.addEventListener('popstate',function(e)&#123; var newPage = e.state.newPage; ajax('GET','./getData.php',doData,'page='+newPage ,true) &#125;) hashchange当页面的hash值改变时触发，常用于构建单页面应用。 hash从无到有，或者从有到无。 demo： 123456789101112131415161718192021222324var item = document.getElementsByClassName('item')[0]; var header = document.getElementsByClassName('header')[0]; var page = ''; function init()&#123; history.replaceState(&#123;newPage:'one'&#125;,null,'?one'); ajax('GET','./getData.php',doData,'page=one' ,true); // method, url, callback, data, flag &#125; init(); function doData(data)&#123; console.log(data); item.innerHTML = data; &#125; header.addEventListener('click',function(e)&#123; page = e.target.getAttribute('data'); history.pushState(&#123;newPage:page&#125;,null,'?'+page); ajax('GET','./getData.php',doData,'page='+page ,true); &#125;); window.addEventListener('popstate',function(e)&#123; var newPage = e.state.newPage; ajax('GET','./getData.php',doData,'page='+newPage ,true) &#125;) 参考链接：https://www.cnblogs.com/jehorn/p/8119062.html Worker概念Worker 接口代表一个可以轻松创建的后台任务，并可以将消息发送回其创建者。创建一个工作程序只要简单的调用Worker() 构造函数，并指定一个要在工作线程中运行的脚本。 worker对象常常用来在后台帮助计算一些数据。 语法12var worker = new Worker('worker.js'); //这里的参数是指worker将要执行的脚本的url，它遵循同源策略 操作方法postMessage(n)向worker的内部作用域发送数据的方法，一次只能发送一个对象，如果想传递多个值，可以使用数组 语法 见下面的demo close()在worker作用域中调用 (在worker.js中调用） 工人自己罢工了 下面这个demo，主线程是html中script脚本，首先worker对象发送一个message（10），在worker.js收到数据后打印出来，最后worker自己关闭了，主线程中的worker对象再发送一个message（100）时，worker.js已经不再工作，故，打印结果是： worker.js 12345678onmessage = function(e)&#123; console.log(e.data); //打印了 close();&#125;function deal(data)&#123; return data * data;&#125; worker.html(作用域) 123456var worker = new Worker('worker.js'); worker.postMessage(10); worker.onmessage = function(e)&#123; worker.postMessage(100); &#125; terminate()在worker对象上调用（主进程的worker对象上的worker.terminate) 老板让工人不工作了 主进程中worker发送message（10），worker.js中收到并打印出来，在发送一个message（1010）回去，主进程收到送过来的message（10 10），打印出来，调用terminate方法，worker对象结束，主进程再发送一个message(100) ，worker.js不再为其打印。 当把worker.terminate()注释掉后： // 第一次发送message js打印 10 并返回10*10 // html 收到100 并打印 随后html发送message 100 // 100 js收到后打印100 并返回100*100 给html //10000 html 收到后打印10000 worker.html 12345678var worker = new Worker('worker.js'); worker.postMessage(10); worker.onmessage = function(e)&#123; console.log(e.data); worker.terminate(); //后面的100就不会发送过去了 worker.postMessage(100); &#125; worker.js 12345678onmessage = function(e)&#123; console.log(e.data); //打印了 postMessage(deal(e.data));&#125;function deal(data)&#123; return data * data;&#125; worker 能够产生出新的 worker，前提是这些 worker 托管于相同的源内来作为它们的父页面（一般不会这么用，因为目前不是所有浏览器都能兼容这个功能）。 此外，worker 还能够使用 XMLHttpRequest 实现网络 I/O 操作， 只不过 XMLHttpRequest 上的responseXML与 channel 两个属性值始终返回 null。 属性onerror在Worker的error事件触发并冒泡时执行 语法： 1myWorker.onerror = function() &#123; ... &#125;; 实例： 12345var myWorker = new Worker("worker.js");myWorker.onerror = function() &#123; console.log('There is an error with your worker!');&#125; 事件message其他特性 worker只是window的子集，只能实现部分功能，不能获取到window, document，所以这里不要引juery zepto。可以引入一些计算类的库。 作用域 globalWorkerScope 可以继续生成worker对象 (chrome暂时还不支持) navigator XMLHttpRequest setTimeout/serInterval GeoLocation概念navigator对象下的 方法获取地理位置信息getCurrentPosition(s,e,p) 参数意义成功的回调函数：s 失败的回调函数：e 参数options 可以定义成一个对象，其中也有一些配置参数如下： enableHighAccuracy 是否需要高精度位置默认false timeout 单位ms 请求超时时间 默认为infinity maximumAge 单位ms， 语法12345678function suc(position)&#123; console.log("success"); console.log(position); &#125; function fail()&#123; console.log("fail"); &#125; window.navigator.geolocation.getCurrentPosition(suc,fail); Geoposition对象属性意义： 属性名 属性意义 latitude 纬度 longitude 经度 altitude 海拔 accuracy 定位精准度，单位是m altitudeAccuracy 海拔精准度，单位是m heading 方向 speed 速度 PositionError 属性值 意义 code=1 用户拒绝 code=2 获取不到 code=3 连接超时 watchPosition方法则不停地取用户的地理位置信息，不停地更新用户的位置信息。位置信息过期时间 设置为0就无条件获取新的地理位置信息 默认0 语法： 1234var id = geolocation.watchPosition(fu); //用于注册监听器，在设备的地理位置发生改变的时候自动被调用。clearWatch(id);//使用 clearWatch 清除监听 devicemotion事件含义：监听加速度变化 语法： 12345window.addEventListener('devicemotion',function(e)&#123; console.log(e); item.innerHTML = e.accelerationIncludingGravity.x + '-' + e.accelerationIncludingGravity.y + '-'+ e.accelerationIncludingGravity.z; &#125;) 包含的属性 accelerationIncludingGravity 重力加速度（包括重心引力，z轴反向加了9.8，在x，y方向上的值两者相同） acceleration 重力加速度（需要陀螺仪支持） rotationRate（alpha，beta，gamma）旋转速率 interval 获取的时间间隔 以上属性均为只读属性。 摇一摇demo 代码： 123456789101112131415161718192021222324252627282930 var SHAKE_THRESHOLD = 800; //定义一个flagvar last_update = 0;var x, y, z, last_x=0, last_y=0, last_z=0;function deviceMotionHeadler(eventData) &#123; var acceleration = eventData.accelerationIncludingGravity; var curTime = new Date().getTime(); if((curTime - last_update) &gt; 300) &#123; //为了提高性能，不需每时每刻就监听加速度的变化，故设置一个时间差，每隔这个事件就看一下加速度变化了没有 var diffTime = curTime - last_update; last_update = curTime; x = acceleration.x; y = acceleration.y; z = acceleration.z; var speed = Math.abs(x + y + z - last_x - last_y - last_z) / diffTime * 10000; //通过公式，计算当下时刻加速度 与定义的flag对比 if(speed &gt; SHAKE_THRESHOLD) &#123; alert('shaked~!'); var div = document.createElement('div'); div.innerText = '11'; document.body.appendChild(div); &#125; last_x = x; last_y = y; last_z = z; &#125;&#125;window.addEventListener('devicemotion', deviceMotionHeadler, false);//整个摇一摇的原理即是通过重力加速度监听器来实现的 deviceorientation事件含义:监听设备在方向上的变化 语法： 123window.addEventListener(deviceorientation, function(event)&#123; console.log(event);&#125;); 属性介绍： 属性名 意义 alpha 表示设备沿z轴上的旋转角度，范围为0~360。 beta 表示设备在x轴上的旋转角度，范围为-180~180。它描述的是设备由前向后旋转的情况。 gamma 表示设备在y轴上的旋转角度，范围为-90~90。它描述的是设备由左向右旋转的情况。 webkitCompassHeading 与正北方向的角度差值。正北为0度，正东为90度，正南为180度，正西为270度。因为0度是正北，所以叫指北针。 webkitCompassAccuracy 指北针的精确度，表示偏差为正负多少度。一般是10。 多媒体audio音频标签语法12&lt;audio src="./src/可能否+-+木小雅.mp3" autoplay controls loop&gt;&lt;/audio&gt;&lt;!--自动播放 添加空间 循环播放--&gt; 属性controls:设置空间 autoplay:自动播放 preload：预加载，规定是否在页面加载后再录视频 ​ none:不需要加载数据 ​ metadata:元数据 诸如时长、比特率、帧大小这样的原数据，而不是媒体内容需要加载 ​ auto：浏览器应当加载它认为适量的媒体内容 loop 是否循环播放影音 currentSrc 资源链接，媒体数据的url地址 ,要在音频或者视频加载之后使用（window.onload) volume 音量 range[0,1] 通过两个button设置音量加减 12345678910111213141516171819up.onclick = function()&#123; if(audio.volume &lt;= 0.9) &#123; audio.volume += 0.1; console.log(audio.volume); &#125;else&#123; audio.volume = 1; &#125; &#125; down.onclick = function()&#123; if(audio.volume &gt;= 0.1)&#123; audio.volume -= 0.1; &#125;else&#123; audio.muted = true; &#125; &#125; muted 是否静音 true|false playbackRate 播放速率 用于指定媒体播放的速度。该属性值为1.0表示正常速度，大于1则表示”快进”，0~1之间表示”慢放”，负值表示回放。 不同浏览器实现的会有所差别，具体看浏览器实现。 currentTime 设置或返回音频/视频播放的当前位置 快进键就是基于该属性设置的 duration 返回音频/视频的时长 TimeRanges对象 played 返回已经播放的时间段 buffered返回当前已经缓冲的时间段 seekable返回用户可以跳转的时间段 这三个对象下都分别有一个length属性、一个start 一个end方法 ​ length属性表示当前的一个时间段 ​ start()返回当前时间段的起始时间点 ​ end()返回当前的结束时间点 语法： 1234audio.played.start(0);//0是指已经播放的第0段开始的时间audio.played.end(0);//已经播放了的第0段结束的时间 paused/seeking/ended paused 判断当前视频或音频是否是暂停状态 是则返回true seeking 当该属性为true时说明，视频或音频正被调节至一个新的播放点 1234audio.onseeking = function()&#123; console.log(00);&#125;//拖动音频或视频的滚动轴时，会不断的打印00 ended如果播放完媒体并且停下来，则ended为true video视频标签语法1&lt;video src="./src/wewe.mp4" width="400" height="300" controls&gt;&lt;/video&gt; 属性和audio通用。但多了一个poster属性（海报） poster： 当视频不可用时，使用一张图片替代，否则是空白 1&lt;video src="./src/wewe.mp4" width="400" height="300" controls&gt;&lt;/video&gt; 方法 play方法 pause方法 reload方法 12345678910play.click = function()&#123; audio.play(); &#125; pause.click = function()&#123; audio.pause(); &#125; reload.click = function()&#123; window.load(); &#125; 事件 play 开始播放的时候触发 pause 暂停触发 loadedmetadata 浏览器获取完媒体的元数据触发（相对loadeddata先触发） loadeddata 浏览器已经加载完当前帧数据准备播放时触发，注意ie8 123456audio.onloadedmetadata = function()&#123; console.log(2); &#125; audio.onloadeddata = function()&#123; console.log(3); &#125; ended 当前播放结束后触发 多类型标签语法： 1234&lt;audio id="music"&gt; &lt;source src="成都.mp3" type="audio/mpeg"&gt; &lt;source src="成都.ogg" type='audio/ogg"'&gt; &lt;/audio&gt; 脚本化语法1234567var audio = new Audio(); audio.src = './src/可能否+-+木小雅.mp3'; audio.controls = true; audio.loop = 'loop'; audio.preload = 'auto'; audio.autoplay = true; document.body.appendChild(audio); #####]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG]]></title>
    <url>%2F2018%2F08%2F19%2Fhtml5_2_svg%2F</url>
    <content type="text"><![CDATA[SVG简介Scalable Vector Graphics（svg，可缩放矢量图形），是html5中一种标签，用于二维矢量图形，SVG图像在放大或者改变尺寸的情况下其图形质量不会有所损失，和canvas不同一点就是canvas在改变尺寸或放大时，图形质量有所损失，图片会失真。 svg元素可以用于在当前文档中内嵌一个独立的svg片段。这个独立的片段拥有独立的视口和坐标系统。 应用场景图表、图表icon、动效、矢量图 SVG和canvasSVG的特点​ 不依赖分辨率，支持事件处理器，最适合带有大型渲染区域的应用程序（如：谷歌地图），复杂度高会减慢渲染速度（任何过度使用DOM的应用都会减慢速度），不适合游戏应用。 Canvas特点​ 依赖分辨率，不支持事件处理器，弱的文本渲染能力能够以png或者jpg格式保存结果图像，最适合图像密集型的游戏 ，其中的许多对象会被频繁重绘。 canvas通过JavaScript来绘制2D图形。canvas是逐像素进行渲染的。在canvas中，一旦图形绘制完成，它就不会继续得到浏览器的关注。如果其对象位置发生变化，那个整个场景也需要重新绘制，包括任何或许已经被图形覆盖的对象。 Canvas SVG 操作对象 基于像素（动态点阵图） 基于图形元素 元素 单个HTML元素 多种图形元素 驱动 只能通过脚本驱动 同时支持css和脚本 事件交互 用户交互到像素点（x，y） 用户交互到图形元素（rect、path） 性能 适合小面积、大数量应用场景 适合大面积、小数量应用场景 SVG元素分类基本形状元素直线标签line，语法： 12&lt;line x1="100" y1="100" x2="200" y2="100"&gt;&lt;/line&gt;&lt;!--起点坐标（x1，y1）终点坐标（x2，y2）--&gt; 矩形标签rect，语法： 12&lt;rect x="50" y="50" width="100" height="100" rx="10"ry="20"&gt;&lt;/rect&gt;&lt;!--起点坐标（x，y）宽度width 高度height 水平和垂直方向上的border-radius rx ry--&gt; 圆形标签circle，语法： 12&lt;circle r="50" cx="220" cy="100"&gt;&lt;/circle&gt;&lt;!--圆心坐标（cx，cy）半径r--&gt; 椭圆标签ellipse，语法： 12&lt;ellipse rx="100" ry="50" cx="400" cy="150"&gt;&lt;/ellipse&gt;&lt;!--圆心坐标（cx，cy）水平方向半轴长rx，垂直方向上的半轴长ry--&gt; 折线标签polyline，语法： 12345678&lt;polyline points="60 50, 75 35, 100 50, 125 35, 150 50,175 35, 190 50"&gt;&lt;/polyline&gt;&lt;!--这里的直线画出来是自动闭合的，也就是会画出几个连续的三角形，要想不闭合，要设置一下css,把fill设置成Transparent 如下--&gt;&lt;style&gt; polyline&#123; fill:transparent； stroke：'pink'; &#125;&lt;/style&gt; 多边形polygon，语法： 12&lt;polygon points="125 125,130 140,120 140"&gt;&lt;/polygon&gt;&lt;!--顶点坐标，最好两个为一组用逗号分开--&gt; 文本text，语法： 1&lt;text x="125" y="220"&gt;hello,world&lt;/text&gt; demo: 1234567891011121314151617181920212223242526272829303132333435 &lt;style&gt; svg&#123; border:1px solid black; &#125; line&#123; stroke:orange; &#125; rect&#123; fill:transparent; stroke:thistle; stroke-width: 10px; &#125; ellipse&#123; fill:springgreen; &#125; polyline&#123; fill:transparent; stroke:thistle; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width="500" height="500"&gt; &lt;line x1 = 100 y1=100 x2=200 y2=200&gt;&lt;/line&gt; &lt;rect x=200 y=200 width=200 height=100 rx=10 ry=10 &gt;&lt;/rect&gt; &lt;circle r=50 cx=400 cy=300&gt;&lt;/circle&gt; &lt;ellipse rx=100 ry=50 cx=400 cy=150&gt;&lt;/ellipse&gt; &lt;polyline points="60 50, 75 35, 100 50, 125 35, 150 50, 175 35, 190 50"&gt;&lt;/polyline&gt; &lt;polygon points="125 125,130 140,120 140"&gt;&lt;/polygon&gt; &lt;text x="125" y="220"&gt;hello word&lt;/text&gt; &lt;/svg&gt;&lt;/body&gt; 效果： pathM L指令语法： 1&lt;path d = "M 10 10 L 20 10" /&gt; 含义：moveTo(10,10) LineTo(20,10);是绝对位置，指从10，10的位置移动到20,10 m l 指令语法： 1&lt;path d = "m 10 10 l 20 10" /&gt; 含义：m（10,10）从距离原点水平距离是10，垂直距离是10的地方开始，水平方向移动20个单位，垂直方向移动10个单位 实际上是 后面的l指令区分大小小，小写是相对路径，大写是绝对路径，见demo： 前者是M L指令 后者是m l 指令 H V 指令语法： 1&lt;path d="M 100 100 H 200 V 200"/&gt; 含义：水平（horizontal lineto）竖直（vertical lineto）方向移动距离 demo： Z指令含义：闭合 不区分大小写。 语法： 1&lt;path d="M 100 100 H 200 V 200 z"/&gt; 圆弧指令A指令含义：画一个圆弧，一共有七个参数 。首先要理解，如果存在椭圆同时与两个点相交，这样的椭圆有两个。 参数名 参数意义 rx 圆弧的x轴半径。 ry 圆弧的y轴半径。 x-axis-ratation 圆弧相对x轴的旋转角度，默认是顺时针，可以设置成负值 large-arc-flag 表示圆弧路径是大圆弧还是小圆弧 1是大圆弧 sweep-flag 表示从起点到终点是顺时针还是逆时针 x 终点x轴坐标 y 终点y轴坐标 语法: 1&lt;path d="M 100 100 A 70 120 0 1 1 150 200"&gt;&lt;/path&gt; 起点是（100,100）的位置 x轴半径是70，y轴半径是120 圆弧旋转了0度，要大圆弧，起点到终点是顺时针，终点坐标是（150,200）效果图如下。 二次贝塞尔曲线Q指令 语法： 1&lt;path d="M 50 150 Q 100 50 200 200 T 400 100"&gt;&lt;/path&gt; T 指令 含义： T x y 延伸贝塞尔曲线 123456789&lt;style&gt; path&#123; stroke:deeppink; fill:transparent; &#125;&lt;/style&gt;&lt;svg width="500" height="500"&gt; &lt;path d="M 50 150 Q 100 50 200 200 T 400 100"&gt;&lt;/path&gt; &lt;/svg&gt; 效果： 三次贝塞尔曲线C指令 C x1 y1, x2 y2, x y S指令 S x2 y2, x y 延伸 语法： 1&lt;path d=&quot;M 50 150 C 100 50 200 200 300 300 S 400 100&quot;&gt;&lt;/path&gt; 多啦a梦demo： 1234567891011121314151617181920212223242526272829303132333435&lt;svg id="Doraemon" width="500" height="500"&gt; &lt;g fill="deepskyblue" stroke="blue" &gt; &lt;path d="M 200 200 A 100 100 0 1 1 300 200"&gt;&lt;/path&gt; &lt;/g&gt; &lt;g fill="white" stroke="blue" &gt; &lt;path d="M 200 200 A 80 80 0 1 1 300 200"&gt;&lt;/path&gt; &lt;/g&gt; &lt;g fill="white" stroke="blue"&gt; &lt;ellipse rx="23" ry="30" cx="225" cy="70"&gt;&lt;/ellipse&gt; &lt;ellipse rx="23" ry="30" cx="271" cy="70"&gt;&lt;/ellipse&gt; &lt;/g&gt; &lt;g&gt; &lt;ellipse rx="4" ry="6" cx="225" cy="85"&gt;&lt;/ellipse&gt; &lt;ellipse rx="4" ry="6" cx="271" cy="85"&gt;&lt;/ellipse&gt; &lt;/g&gt; &lt;g fill="red" stroke="black"&gt; &lt;circle r='10' cx="247.5" cy="100"&gt;&lt;/circle&gt; &lt;/g&gt; &lt;g fill="white" &gt; &lt;circle r='5' cx="250" cy="98"&gt;&lt;/circle&gt; &lt;/g&gt; &lt;g fill="transparent" stroke="red" stroke-width="10px" stroke-lineCap="round"&gt; &lt;path d="M 200 200 L 300 200 "&gt;&lt;/path&gt; &lt;/g&gt; &lt;g stroke="black" fill="transparent"&gt; &lt;path d="M 180 110 L 220 122"&gt;&lt;/path&gt; &lt;path d="M 175 128 L 220 126"&gt;&lt;/path&gt; &lt;path d="M 180 147 L 220 135"&gt;&lt;/path&gt; &lt;path d="M 247.5 110 L 247.5 174"&gt;&lt;/path&gt; &lt;path d="M 200 150 A 65 65 0 0 0 300 150"&gt;&lt;/path&gt; &lt;path d="M 270 122 L 315 110"&gt;&lt;/path&gt; &lt;path d="M 270 126 L 315 128"&gt;&lt;/path&gt; &lt;path d="M 270 135 L 315 147"&gt;&lt;/path&gt; &lt;/g&gt; 效果： 容器元素defs含义： SVG允许我们定义以后需要重复使用的图形元素。建议把所有需要再次使用的引用元素定义在defs元素里面。这样可以增加SVG内容的易读性和可访问性。在defs元素中定义的图形元素不会直接呈现。你可在你视口的任意地方利用&lt;use&gt; 元素呈现这些元素。 语法： 12345678910111213&lt;svg width="80px" height="30px" viewBox="0 0 80 30" xmlns="http://www.w3.org/2000/svg"&gt; &lt;defs&gt; &lt;linearGradient id="Gradient01"&gt; &lt;stop offset="20%" stop-color="#39F" /&gt; &lt;stop offset="90%" stop-color="#F3F" /&gt; &lt;/linearGradient&gt; &lt;/defs&gt; &lt;rect x="10" y="10" width="60" height="10" fill="url(#Gradient01)" /&gt;&lt;/svg&gt; g元素含义：元素g是用来组合对象的容器。添加到g元素上的变换会应用到其所有的子元素上。添加到g元素的属性会被其所有的子元素继承。此外，g元素也可以用来定义复杂的对象，之后可以通过&lt;use&gt;元素来引用他们。 语法： 123456&lt;g stroke="green" fill="white" stroke-width="5"&gt; &lt;circle cx="25" cy="25" r="15" /&gt; &lt;circle cx="40" cy="25" r="15" /&gt; &lt;circle cx="55" cy="25" r="15" /&gt; &lt;circle cx="70" cy="25" r="15" /&gt; &lt;/g&gt; demo： 渐变元素线性渐变linearGradient 语法： 1234567&lt;defs&gt; &lt;linearGradient id="bg1" x1="0" y1="0" x2="0" y2="100%"&gt; &lt;stop offset="0%" style="stop-color:rgb(255,255,0);"/&gt; &lt;stop offset="100%" style="stop-color:rgb(255,0,0);"/&gt; &lt;/linearGradient&gt;&lt;/defs&gt;&lt;rect x="0" y="0" width="500" height="500"style="fill:url(#bg1)"/&gt; 效果： 径向渐变语法： 1234567&lt;defs&gt; &lt;radialGradient id="bg2" cx="50%" cy="50%" r="50%" fx="50%" fy="50%"&gt; &lt;stop offset="0%" style="stop-color:green;"/&gt; &lt;stop offset="100%" style="stop-color:red;"/&gt; &lt;/radialGradient&gt;&lt;/defs&gt;&lt;rect x="0" y="0" width="500" height="500" style="fill:url(#bg2)"/&gt; 效果： SVG滤镜元素高斯滤镜feGaussianBlur ​ 1234567&lt;defs&gt; &lt;filter id="Gaussian_Blur"&gt; &lt;feGaussianBlur in="SourceGraphic" stdDeviation="20"/&gt; &lt;/filter&gt;&lt;/defs&gt;&lt;rect x="100" y="0" width="100" height="100" fill=”yellow” /&gt;&lt;rect x="0" y="0" width="500" height="500" fill=”yellow” style="filter:url(#Gaussian_Blur)"/&gt; 效果： 其他滤镜可以参考一下网址 http://www.w3school.com.cn/svg/svg_filters_intro.asp 样式属性fillstrokestroke-widthstroke-opacity/fill-opacitystroke-lineCap三种属性值：butt round square stroke-linejoin三种属性值：bevel round miter SVG路径stroke-dasharray语法: 12345path&#123; stroke-dasharray: 10px 30px 40px; /* 画10px 空30px的空隙 */ /* 画10 空30 画 40 空10 画30 空40.。。 */&#125; stroke-dashoffset语法： 123456path&#123; stroke-dasharray: 10px 30px 40px; stroke-dashoffset:10px; /* 画10px 空30px的空隙 */ /* 画10 空30 画 40 空10 画30 空40.。。 */&#125; demo: 代码： 123456789101112131415161718path&#123; stroke:deeppink; fill:transparent; stroke-width: 20px; stroke-dasharray: 10px 20px; /* 画10px 空30px的空隙 */ /* 画10 空30 画 40 空10 画30 空40.。。 */ stroke-dashoffset:10px; animation: move 3s linear infinite; &#125; @keyframes move &#123; 0%&#123; stroke-dashoffset: 10px; &#125; 100%&#123; stroke-dashoffset: 500px; &#125; &#125; getTotalLength含义：获取路径的总长度 语法： 12var length = path1.getTotalLength;console.log(length); getPointAtLengthgetPointAtLength(x) 含义：获取路径上距离起始点距离x长度的点的坐标,返回一个坐标 语法： 12var point = path1.getTotalLength(50);console.log(point); 严格来说上面两方法只适用于path元素，但各个浏览器实现起来都会有一点区别。例如谷歌浏览器也能获取到line元素的路径长度。 SVG视区viewPortviewPort表示SVG可见区域的大小，画布大小 如： 1&lt;svg width="500" height="300" &gt;&lt;/svg&gt; 当前svg视区的宽度是500单位，高度是300单位。 ViewBoxviewBox表示视区盒子 我们用一个例子来说明： 123&lt;svg width="400" height="300" viewBox="0,0,40,30" style="border:1px solid #cd0000;"&gt; &lt;rect x="10" y="5" width="20" height="15" fill="#cd0000"/&gt;&lt;/svg&gt; viewBox=“0,0,40,30” 40 30是指当前svg的实际大小 但是呢 它放大十倍给你看。所以如果说，你画一个半径是100px的圆，那你实际看到的圆就是1000px的。 preserveAspectRatio含义：对svg操作，有两类值 第一部分值又由两部分组成，前半部表示x方向对齐方式，后半部分表示y方向对齐方式 值 含义 xMin viewPort和viewBox左边对齐 xMid viewPort和viewBox x轴中心对齐 xMax viewPort和viewBox右边对齐 YMin viewPort和viewBox上边缘对齐，注意Y是大写 YMid viewPort和viewBox y轴中点对齐。Y大写 YMax viewPort和viewBox下边缘对齐。 第二部分用来表示填充方式 meet：保持纵横比缩放viewBox适应viewPort slice：保持纵横比同时比例小的方向放大填满viewport(在均匀缩放的同时保持viewbox的宽高比) none：扭曲纵横比以充分适应viewport 语法： 1svg.setAttribute(&quot;preserveAspectRatio&quot;, &quot;xMinYMin meet&quot;); js生成SVG元素 创建SVG元素需要指定命名空间 SVG元素对象一般通过调用setAttribute()方法来设定属性值 demo代码： 12345var svg = document.createElementNS('http://www.w3.org/2000/svg','svg'); svg.setAttribute('width',500); svg.setAttribute('height',500); document.body.appendChild(svg); 仪表盘demo： HTML： 12345&lt;input type="text" id='btn'&gt; &lt;svg width="500" height="500"&gt; &lt;path id="path1"d="M 200 300 A 100 100 0 1 1 300 300"&gt;&lt;/path&gt; &lt;path id="path2"d="M 200 300 A 100 100 0 1 1 300 300"&gt;&lt;/path&gt; &lt;/svg&gt; CSS： 123456789101112131415161718192021svg&#123; border: 1px solid black; &#125; path&#123; fill:transparent; stroke-width: 15px; stroke-linecap: round; &#125; #path1&#123; stroke:#ccc; &#125; #path2&#123; stroke:darkorange; stroke-dasharray: 1000px 1000px; stroke-dashoffset: 1000px; transition: all 1s linear ; &#125;.active&#123; transition: all 1s linear ; &#125; js: 1234567891011121314var len = path2.getTotalLength(); console.log(len); btn.onblur = function()&#123; var value = this.value; var total = len * value / 100; console.log(total); path2.classList.add('active'); path2.style.strokeDashoffset = 1000 - total + 'px'; &#125; btn.onfocus = function()&#123; btn.value = ''; path2.classList.remove('active'); path2.style.strokeDashoffset = 1000 + 'px'; &#125; loading demo： 1234567891011121314151617181920212223242526272829303132333435 &lt;style&gt; svg&#123; transform-style: preserve-3d; &#125; #circle2&#123; fill:transparent; stroke-width:15px; stroke:gray; stroke-linecap: round; &#125; #circle1&#123; fill:transparent; stroke-width:15px; stroke:orange; stroke-dasharray: 50px 2000px; stroke-linecap: round; transform-origin: 50% 50%; animation:move 0.6s linear infinite; &#125; @keyframes move &#123; 0%&#123; transform: rotateZ(0deg); &#125; 100%&#123; transform: rotateZ(360deg); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width="500" height="500"&gt; &lt;circle id="circle2" r="50" cx="250" cy="250"&gt;&lt;/circle&gt; &lt;circle id="circle1" r="50" cx="250" cy="250"&gt;&lt;/circle&gt; &lt;/svg&gt;&lt;/body&gt; 效果： 写字demo：]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas]]></title>
    <url>%2F2018%2F08%2F19%2Fhtml5_1_canvas%2F</url>
    <content type="text"><![CDATA[​ canvas简介canvas&lt;canvas&gt;是HTML5新增的，一个可以使用脚本（JavaScript）在其中绘制图像的HTML元素。它可以用来制作照片或者制作简单的动画，甚至可以进行实时视频处理和渲染。 它最初是由苹果内部使用自己MacOS X Webkit推出，供应用程序使用像仪表盘的构建和Safari浏览器的使用。Mozilla程序Gecko 1.8 (Firefox 1.5)开始支持&lt;canvas&gt;，Internet Explorer从IE9开始使用&lt;canvas&gt;.Chrome和Opera 9+也支持&lt;canvas&gt; &lt;canvas&gt;元素看起来和&lt;img&gt;很相像，唯一不同的是它没有alt属性和src属性。实际上canvas标签只有两个属性width和height。这些都是可选的。当没有设置宽度和高度的时候，canvas会初始化宽度为300像素和高度为150像素。该元素也可以可以用css样式来定义大小，但在绘制时图像会通过伸缩来适应它的框架尺寸：如果css的尺寸与初始画布的比例不一致，它会出现扭曲。 注意：如果绘制时，画面扭曲，则尝试用canvas本身的width和height属性来给canvas定义宽高，而不是用css。 12&gt; &lt;canvas width='500' height='500s'&gt;&lt;/canvas&gt;&gt; 与img元素不同，canvas元素需要结束标签\。如果结束标签不存在， 则文档其余部分会被认为是替代内容，将不会显示出来。 canvas兼容&lt;canvas&gt;很容易定义一些替代内容，由于某些较老的浏览器（尤其是IE9之前的浏览器）或者文本浏览器不支持HTML元素‘canvas’ ，在这些浏览器上，我们应该总能展示替代内容。 替代方法： 在&lt;canvas&gt;标签中提供了替换内容。不支持\的浏览器将会忽略容器并在其中渲染后备内容。而支持&lt;canvas&gt;的浏览器将会忽略在容器中包含的内容，并且只是正常渲染canvas。 如： 1234567&lt;canvas id="stockGraph" width="150" height="150"&gt; current stock price: $3.15 +0.15&lt;/canvas&gt;&lt;canvas id="clock" width="150" height="150"&gt; &lt;img src="images/clock.png" width="150" height="150" alt=""/&gt;&lt;/canvas&gt; 渲染上下文canvas起初是空白的。为了展示，首先脚本需要找到一个渲染上下文，然后在它的上面绘制和处理要展示的内容。&lt;canvas&gt;元素中有一个getContext()方法，这个方法是用来获取渲染上下文 和它的绘画功能。getContext()只有一个参数，上下文的格式。 1234 //获取canvas元素var oCanvas1 = document.getElementById('canvas1'); //获取一个canva画布的上下文对象var ctx = oCanvas1.getContext('2d'); //相当于画笔 canvas绘制图形栅格如图所示：画布栅格（Canvas grid）的起点左上角，以画一个正方形为例，它是坐标（x,y）指的是正方形左上角的坐标距离画布远点的距离x和y。在后面的学习中，我们会学校画布平移，到那时候，画布的坐标原点将不再是左上角了。 Canvas属性样式fillStyle描述颜色和样式的属性。默认值是黑色（#000）。 font绘制文字时，当前字体样式的属性。使用和css font规范相同的字符串值。默认字体是10px sans-serif。 globalAlpha透明度 线条lineCap指定如何绘制每一条线段末端的属性。有三种可能的值：butt、round 、square。默认值是butt 参数含义： butt: 线段末端以方形结束。 round：线段末端以圆形结束 square：线段末端以方形结束，但是增加了一个宽度与线段相同，但高度是线段一半的矩形区域。 lineJoin用来设置2个长度不为0的相连部分（线段，圆弧，曲线）如何连接在一起的属性（长度为0的变形部分，其指定的末端和控制点在同一位置，会被忽略）。有三种参数：miter、round、bevel 参数含义： miter：通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。这个设置可以通 bevel：在相连部分的末端填充一个额外的以三角形为底的区域， 每个部分都有各自独立的矩形拐角。 round：通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。 圆角的半径是线段的宽度。 以上两种属性值含义如图： lineWidth设置线段的厚度。 miterLimit设置斜接面限制比例的属性。 当获取属性值时， 会返回当前的值（默认值是10.0），前提是只有当lineJoin显示为“miter”时。如果斜接长度超过miterLimit的值，变成bevel。 斜接长度是指 两条线交汇处，内角和外角之间的距离。 阴影shadowColorshadowOffsetXshadowOffsetYshadowBlur 这里的阴影偏移量不受坐标系变换的影响 demo: 123456ctx.fillStyle = &apos;orange&apos;; ctx.shadowColor = &apos;black&apos;; //加上黑色阴影 ctx.shadowOffsetX = 30; ctx.shadowOffsetY = 30; //阴影偏移 不受坐标系变换的影响 ctx.shadowBlur = 30; ctx.fillRect(100, 100, 200, 200); 效果： 合成globalCompositeOperation含义：属性设置要在绘制新形状时应用的合成操作的类型，其中type是用于标识要使用的合成或混合模式操作的字符串。新像素和原像素的合并方式 ，有11种值，其中默认值为：‘source-over’ 如图： 一些常用的：source-over, destination-over, copy 语法： 1ctx.globalCompositeOperation = type; demo： 1234567ctx.globalCompositeOperation = "xor";ctx.fillStyle = "blue";ctx.fillRect(10, 10, 100, 100);ctx.fillStyle = "red";ctx.fillRect(50, 50, 100, 100); 效果： Canvas方法save()含义： canvas 2d api通过将当前状态放入栈中，保存canvas全部状态的方法。 保存到栈中的绘制状态由下面部分组成： 当前变换的矩阵 当前的剪切区域 当前的虚线列表 以下属性当前的值： strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation, font, textAlign, textBaseline, direction, imageSmoothingEnabled. 语法： 1ctx.save(); restore()含义： Canvas 2D API 通过在绘图状态栈中弹出顶端的状态，将 canvas 恢复到最近的保存状态的方法。 如果没有保存状态，此方法不做任何改变。 语法： 1ctx.restroe(); demo: 12345678910var canvas = document.getElementById("canvas");var ctx = canvas.getContext("2d");ctx.save(); // save the default statectx.fillStyle = "green";ctx.fillRect(10, 10, 100, 100);ctx.restore(); // restore to the default statectx.fillRect(150, 75, 100, 100); 效果： createPattern() 平移translate()含义：Canvas 2D API 通过在网格中移动canvas 和canvas原点x水平方向、原点y垂直方向，添加平移变换的方法。 说的通俗一点就是—–&gt;通过平移画布改变了原点的位置 语法： 1ctx.translate(x,y); 参数：X 水平移动的方向：Y：垂直移动的方向 裁剪clip()含义：将当前创建的路径设置为当前剪切的路径的方法，剪切下来的路径之外（默认情况下）的图形不允予显示。 语法： 123ctx.clip();ctx.clip(fillRule);ctx.clip(path,fillRule); 参数意义：fillRule根据某种填充规则进行填充（详见本文档最下方） demo： 1234ctx.arc(100, 100, 75, 0, Math.PI * 2, false); ctx.stroke(); //ctx.clip(); ctx.fillRect(0, 0, 100, 100); 效果： 取消clip方法的注释后： 缩放scale()含义：是 Canvas 2D API 根据 x 水平方向和 y 垂直方向，为canvas 单位添加缩放变换的方法。 默认的，在canvas中一个单位实际上就是一个像素。例如，如果我们将0.5作为缩放因子，最终的单位会变成0.5像素，并且形状的尺寸会变成原来的一半。相似的方式，我们将2.0作为缩放因子，将会增大单位尺寸变成两个像素。形状的尺寸将会变成原来的两倍。 语法： 1ctx.scale(x,y); 参数：x：水平方向的缩放因子，y:垂直方向的缩放因子； 其中x，y可以是负数，可想而知，当x是负数时，x= -1时相当于 1—&gt;0—&gt;-1 即是水平翻转上下文 ，y= -1时则是垂直翻转上下文 demo： 12345678910111213&lt;script&gt; var oCanvas1 = document.getElementById('canvas1'); //获取一个canva画布的上下文对象 var ctx = oCanvas1.getContext('2d'); //相当于画笔 ctx.save(); ctx.fillStyle = 'orange'; ctx.fillRect(0,0,50,50); ctx.restore(); // ctx.scale(2,1); ctx.fillRect(60,60,50,50); &lt;/script&gt; 效果： 添加了scale()方法后： 旋转rotate()含义：Canvas 2D API 在变换矩阵中添加旋转的方法。 旋转的中心点一直是canvas的起始点，若想改变起始点可以通过translate方法来移动canvas 语法： 1ctx.rotate(angle); 参数意义： angle表示一个顺时针旋转角度并且用弧度表示，可以是复数。 一定要注意angle是弧度，也可以把它转换成角度，可以使用公式：degree * Math.PI/180 矩阵重置setTransform(a,b,c,d,e,f) 含义： Canvas 2D API 使用单位矩阵重新设置（覆盖）当前的变换并调用变换的方法，此变换由方法的变量进行描述。 语法: 1ctx.setTransform(a,b,c,d,e,f); 参数意义：水平缩放、水平倾斜、垂直倾斜、垂直缩放、水平移动（dx）、垂直移动（dy） 旋转角度公式：（以旋转45°为例） 123&gt; var deg = Math.PI/180;&gt; ctx.transform(Math.cos(deg*45),Math.sin(deg*45),-Math.sin(deg*45),Math.cos(deg*45),0,0);&gt; demo： 12345var canvas = document.getElementById("canvas");var ctx = canvas.getContext("2d");ctx.setTransform(1,1,0,1,0,0);ctx.fillRect(0,0,100,100); 效果： 注意的是，该方法会覆盖原来的矩阵。下面的transform不会覆盖。 Transform(a,b,c,d,e,f) 含义： Canvas 2D API 使用矩阵多次叠加当前变换的方法，矩阵由方法的参数进行描述。你可以缩放、旋转、移动和倾斜上下文。与上文的setTranform方法不同，它是叠加，即不会覆盖原来的矩阵 语法： 1ctx.Transform(1,1,0,1,0,0); 参数意义：同上。 渐变线性渐变createLinearGradient(x0,y0,x1,y1); 该方法返回一个线性CanvasGradient对象。 含义： 语法： 1var cg = ctx.createLinearGradient(0,0,200,200); 参数意义：起点坐标（x0,y0) 终点坐标(x1,y1); 使用该方法创建canvasGradient对象成功后，就可以使用对象上的addColorStop方法，根据指定的偏移和颜色定义一个新的终止。 如例子所示，渐变允许赋值给当前的fillStyle，使用fillRect方法是，在canvas上绘制效果 如下: 代码： 123456789var oCanvas1 = document.getElementById('canvas1'); //获取一个canva画布的上下文对象var ctx = oCanvas1.getContext('2d'); //相当于画笔var bg = ctx.createLinearGradient(0,0,400,200); //渐变 线性渐变 var bg1 = ctx.createRadialGradient(250,250,100,250,250,250); //圆形渐变 bg.addColorStop(0,'black'); bg.addColorStop(1,'white');ctx.fillStyle = bg;ctx.fillRect(0,0,4000,200); 效果： 放射性渐变createRadialGradient(x0,y0,r0,x1,y1,r1); 含义：根据参数，确定两个圆的坐标和半径，绘制放射性渐变的方法，方法返回值为CanvasGradient。 语法： 1var cg = ctx.createRadialGradient(x0,y0,r0,x1,y1,r1); 参数意义:初始圆形的坐标(x0,y0)和半径r0，结束圆形的坐标(x1,y1)和半径r1。 demo： 123456789var oCanvas1 = document.getElementById('canvas1'); //获取一个canva画布的上下文对象 var ctx = oCanvas1.getContext('2d'); //相当于画笔 var bg= ctx.createRadialGradient(250,250,50,250,250,100); //圆形渐变 bg.addColorStop(0,'white'); bg.addColorStop(0.5,'black'); bg.addColorStop(1,'white'); ctx.fillStyle = bg; ctx.fillRect(0,0,500,500); 效果： 绘制路径图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。一个路径，甚至一个子路径，都是闭合的。使用路径绘制图形需要一些额外的步骤。 首先，你需要创建路径的起始点。 然后使用画图命令去画出路径。 之后把路径封闭。 路径生成后，就能通过描边或者填充路径来渲染图形。 用到的函数： 新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。 1ctx.beginPath(); beginPath() 生成路径的第一步就是beginPath()，这条命令的意义是重新生成一条新的路径，接下来的所有绘制的路径都是这个路径的子路径，当canvas刚刚创建的时候，我们通常使用moveTo()命令来构建第一条路径。我们总是要在设置路径后，专门指定起始位置。 闭合路径后，图形绘制命令又重新回到上下文中。 1ctx.closePath(); closePath() 闭合路径不是必需的，当lineTo(）命令绘制的结束点和起始点一致时，就已经是闭合的了，同理， 调用fill函数时，所有没有闭合的形状都会自动闭合，则无需再调用闭合函数。但是调用了stroke的话，是不会自动闭合的 stroke()含义：使用非零环绕规则，根据当前的画线样式，绘制当前或已经存在的路径的方法。 语法： 1ctx.stroke(); fill()含义：根据当前的填充样式，填充当前或已存在的路径的方法。采取非零环绕或者奇偶环绕规则。 语法： 1ctx.fill(); moveTo()含义：将笔触移动到指定的坐标上去，当canvas刚刚创建的时候，我们通常使用moveTo()命令来设置起点。 语法： 1ctx.moveTo(x,y); lineTo()含义：绘制一条从当前位置到指定x以及y位置的直线。 语法： 1lineTo(x,y); demo： 12345678910111213141516171819202122232425262728&lt;style&gt; #canvas1&#123; border:1px solid black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="canvas1" width=500 height=500&gt;&lt;/canvas&gt; &lt;!--添加一个canvas标签 确定狂傲--&gt; &lt;script&gt; //获取canvas元素 var oCanvas1 = document.getElementById('canvas1'); //获取一个canva画布的上下文对象 var ctx = oCanvas1.getContext('2d'); //相当于画笔 ctx.moveTo(100,100); //路径绘制的起始点 ctx.lineTo(200,100);//画笔以线的形式画出来 ctx.lineTo(200,200); // ctx.lineTo(100,100); // ctx.lineTo(120,100); ctx.closePath();//闭合路线 将起始点和终止点连接起来 ctx.strokeStyle ="green"; //描边颜色 ctx.lineWidth = 40; //描边宽度 ctx.fillStyle = "red";//填充颜色 ctx.stroke();//画线，描边 ctx.fill(); //填充 &lt;/script&gt; 效果: 绘制矩形fillRect() 绘制一个填充的矩形 fillRect()方法 123var canvas1 = document.getElementById('canvas1');vat ctx = canvas1.getContext();ctx.fillRect(x,y,width,height); strokeRect() 绘制一个矩形的边框 strokeRect()方法 1ctx.strokeRect(x,y,width,height); clearRect() 清楚指定的矩形区域，让清楚部分完全透明clearRect()方法 1ctx.clearRect(x,y,width,height); 通过clearRect()方法，我们可以做一个简单的动起来的小方块 代码： 12345678910111213141516171819202122&gt; var oCanvas1 = document.getElementById('canvas2'); &gt; //获取一个canva画布的上下文对象&gt; var ctx = oCanvas1.getContext('2d'); //相当于画笔&gt;&gt; var w = oCanvas1.width;&gt; var h = oCanvas1.height;&gt; var y = 100;&gt; function drawRect(y)&#123;&gt; ctx.fillRect(100,y,30,30);&gt; &#125;&gt;&gt; var timer = setInterval(function()&#123;&gt; ctx.clearRect(0,0,500,500)&gt; drawRect(y);&gt; y += 3;&gt; if(y &gt; 470)&#123; &gt; clearInterval(timer);&gt; drawRect(470);&gt; &#125;&gt; &#125;,50);&gt;&gt; 效果： demo: 12345678var canvas = document.getElementById('canvas');if (canvas.getContext) &#123;var ctx = canvas.getContext('2d');ctx.fillRect(25,25,100,100);ctx.clearRect(45,45,60,60);ctx.strokeRect(50,50,50,50);&#125; 效果： 圆弧arc()方法1arc(x,y,radius,startAngle,endAngle,antiClockwise); 参数意义：画一个以（x，y）为圆心，以radius为半径的圆弧，从起始弧度到弧度角度，按照antiClockwise给定的方向（默认为顺时针方向），false为逆时针（也可以是0或1），按照坐标轴的的方向， arcTo()方法1arcTo(x1,y1,x2,y2,radius); 含义： 根据控制点和半径绘制圆弧路径，使用当前的描点(前一个moveTo或lineTo等函数的止点)。根据当前描点与给定的控制点1连接的直线，和控制点1与控制点2连接的直线，作为使用指定半径的圆的切线，画出两条切线之间的弧线路径。 参数意义：控制点1的坐标（x1,y1）,控制点2的坐标(x2,y2); 圆的半径。 demo：画一个圆角 12345678910&lt;script&gt; var oCanvas1 = document.getElementById('canvas2'); //获取一个canva画布的上下文对象 var ctx = oCanvas1.getContext('2d'); //相当于画笔 ctx.moveTo(250,250); ctx.arcTo(350,250,350,350,30); //画圆角 ctx.stroke();&lt;/script&gt; 原理： 效果： 图片的使用图像操作能力是canvas的一大特性，它可以用于动态图像合成或者图形的背景，以及游戏界面等等。浏览器支持的任意格式的外部图片，都可以使用，比如PNG，GIF或者JEPG.。甚至可以将同一页面中其他canvas元素生成的图片作为图片源。 引入图像到canvas中的操作步骤: 获得一个指向HTMLImageElement 的对象或另个canvas元素的引用作为图片源，也可以通过提供一个url的方式使用图片。 使用drawImage函数将图片绘制到画布上。 drawImage()方法含义：获取到image元素（即获取到图片）后，对照片进行绘制。 语法： 123ctx.drawImage(image, dx, dy); //image是生成的Image对象ctx.drawImage(image, dx, dy, dWidth, dHeight);ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight); 参数意义： 参数 参数意义 image 绘制到上下文的元素，允许任何的canvas图像源，CanvasImageSource、HTMLImageElement、HTMLVideoElement或者HTMLCanvasElement。 dx，dy 绘制目标左上角在canvas中的坐标 sx，sy 绘制目标的元素的起始点（左上角）坐标 sWidth、sHeight 绘制目标的宽高 dWidth, dHeight 绘制目标元素图片所存区域的宽高 ！注意：当脚本执行后，图片开始装载，如果图片没有装载完成（但是在一些旧的浏览器中可能会抛出异常）。所以我们会用load事件来确保我们在操作图片时，图片已经加载完毕了。 来个demo：canvas是500*500的画布 123456789101112131415161718192021&lt;script&gt;//绘制图片 var img = new Image(); img.src = './2.jpg'; // img.style.backgroundRepeat='no-repeat'; img.onload = function()&#123; ctx.drawImage(img,200,200,300,300); var data = oCanvas1.toDataURL(); // 同源策略的限制（开启服务器） console.log(data); &#125; //将canvas内容导出 // var date = oCanvas1.toDataURL(); // 同源策略的限制（开启服务器） //获取canvas的像素信息 ctx.getImageData(x, y, dx, dy) // 同源策略 ctx.createImageData(w,h) //创建新的空白imagedata对象 一般不用 ctx.putImageData(imgData,x,y); //将图像数据放回到画布上 &lt;/script&gt; 效果： getImageData()含义：这个方法返回一个ImageData对象，用来描述canvas区域隐含的像素数据，这个区域可以通过矩形表示。 该方法受同源策略的限制。 语法： 1ctx.getImageData(sx,sy,sw,sh); 参数意义：要被提取图像左上角的坐标（sx，sy）以及宽高sw和sh。 demo： 12var data = ctx.getImageData(sx,sy,sw,sh);console.log(data); 结果： 关于ImageData的内容可以参见一下网址： https://www.cnblogs.com/st-leslie/p/8317850.html?utm_source=debugrun&amp;utm_medium=referral createImageData(） 创建新的空白imagedata对象 一般不用 语法： 1ctx.createImageData(500,500);//参数为新image对象的宽度和高度 putImageData(）将图像数据放回画布上 语法： 1234ctx.putImageData(imgData,dx,dy)//参数为image对象名，图片在canvas图像中的偏移量ctx.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);//dirtyX、dirtyY是数据图像左上角的坐标// dirtyWidth, dirtyHeight是imagedata中数据的矩形的宽度和高度，默认是数据的宽高。 canvas对图片的一些处理，可参考 https://www.cnblogs.com/st-leslie/p/8317850.html?utm_source=debugrun&amp;utm_medium=referral 文本fillText()含义：是 Canvas 2D API 在 (x, y)位置填充文本的方法。如果选项的第四个参数提供了最大宽度，文本会进行缩放以适应最大宽度。 语法： 1ctx.fillText(text, x, y [, maxWidth]); 参数意义： 前三个和strkeText一样，最后一个可选参数maxwidth是指，绘制的最大宽度。如果指定了值，并且经过计算字符串的值比最大宽度还要宽，字体为了适应会水平缩放（如果通过水平缩放当前字体，可以进行有效的或者合理可读的处理）或者使用小号的字体。 demo： 12ctx.font = &quot;48px serif&quot;;ctx.fillText(&quot;Hello world&quot;, 50, 100); 效果： strokeText()含义：绘制文本的方法 语法： 1void ctx.strokeText(text, x, y [, maxWidth]); 参数意义：text,使用当前font，textAlign、textBaseLine和direction的值对文本进行渲染。（x，y）是文本起始点的坐标。 demo： 12345var canvas = document.getElementById("canvas");var ctx = canvas.getContext("2d");ctx.font = "48px serif";ctx.strokeText("Hello world", 50, 100); 效果： 贝塞尔曲线二次贝塞尔曲线quadraticCurveTo(x1, y1, ex,ey ) 参数意义：（x1，y1）控制点 （ex，ey）结束点 demo： 1234567891011121314ctx.beginPath();ctx.moveTo(50, 20);ctx.quadraticCurveTo(230, 30, 50, 100);ctx.stroke();ctx.fillStyle = 'blue';// start pointctx.fillRect(50, 20, 10, 10);// end pointctx.fillRect(50, 100, 10, 10);ctx.fillStyle = 'red';// control pointctx.fillRect(230, 30, 10, 10); 效果： 三次贝塞尔曲线语法： 1ctx.bezierCurveTo(x1, y1, x2, y2, ex, ey) 参数意义:x1,y1，x2,y2 控制点 ex,ey 结束点 四次贝塞尔曲线Canvas填充规则当我们用到 fill（或者 clip和isPointinPath ）你可以选择一个填充规则，该填充规则根据某处在路径的外面或者里面来决定该处是否被填充，这对于自己与自己路径相交或者路径被嵌套的时候是有用的。 fillRule有两个可能的值 nonzero：默认值 evenodd： 来一个选择了evenodd的demo：$$ $$ 1234567function draw() &#123; var ctx = document.getElementById('canvas').getContext('2d'); ctx.beginPath(); ctx.arc(50, 50, 30, 0, Math.PI*2, true); ctx.arc(50, 50, 15, 0, Math.PI*2, true); ctx.fill("evenodd");&#125; 效果： ​ //举例 ：高斯模糊 //练习：通过对canvas的像素操作将一黑色矩形变成灰色 //取到canvas的图片对像素进行处理 再用putImage将操作的canvas图片放回画布上 验证码demo]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Drag Websocket 文件读取 Echarts]]></title>
    <url>%2F2018%2F08%2F19%2Fcss3_10_%2F</url>
    <content type="text"><![CDATA[drag可拖拽元素含义使某元素变成可拖拽元素，设置了draggable的元素称为被拖拽元素。 语法1234567891011121314151617 &lt;style&gt; #item&#123; width: 100px; height: 100px; background:orange; &#125; .wrapper&#123; width: 200px; height: 200px; border: 1px solid black; margin-top:20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="item" draggable="true"&gt;&lt;/div&gt; &lt;div class="wrapper"&gt;&lt;/div&gt; 相关事件dragstart当拖拽发生时被触发 语法： 12345678&lt;script&gt; var item = document.getElementById('item'); item.addEventListener('dragstart',function()&#123; console.log("draggstart"); &#125;); &lt;/script&gt; dragend拖拽完成时触发 语法： 12345678&lt;script&gt; var item = document.getElementById('item'); item.addEventListener('dragend',function()&#123; console.log("dragend"); &#125;); &lt;/script&gt; dragenter被拖拽元素进入到目标元素时被触发 语法： 123item.addEventListener('dragenter',function()&#123; console.log('dragenter'); &#125;) dragover被拖拽元素在目标元素中移动时触发，所以事件要写在wrapper上面 123wrapper.addEventListener('dragover',function()&#123; console.log('dragover'); &#125;) drop被拖拽元素在目标元素上松开鼠标时触发的时间 需要取消dragover的默认行为才会触发drop事件 语法： 1234567wrapper.addEventListener('dragover',function(e)&#123; e.preventDefault(); console.log('dragover'); &#125;) wrapper.addEventListener('drop',function()&#123; console.log('drop'); &#125;) 效果： DragEvent事件对象传值e.dataTransfer.setData(‘data’,e.target.id); 取值e.dataTransfer.getData(‘data’); 含义：当被拖拽元素由很多个的时候，我只要拖拽其中任何一个都会触发相关事件，并且不知道此时我们拖拽的是哪一个，所以我们可以通过setdata方法将我们需要的被拖拽元素的信息传到想要传送的事件里。 例如，我们可以将被拖拽的元素放到目标元素中 语法： 123456789101112 var item = document.getElementById('item'); var item2 = document.getElementById('item2'); var wrapper = document.getElementsByClassName('wrapper')[0]; item.addEventListener('dragstart',function(e)&#123; e.dataTransfer.setData('data',this.id); &#125;);wrapper.addEventListener('drop',function(e)&#123; var data = e.dataTransfer.getData('data'); wrapper.appendChild(document.getElementById(data)); console.log(data); &#125;) 效果： 列表的排序和删除： 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 &lt;style&gt; *&#123; margin:0; padding: 0; &#125; ul li&#123; display: block; width: 200px; height: 20px; color: white; background: black; line-height: 20px; text-align: center; margin-bottom:10px; &#125; .wrapper&#123; width: 300px; height: 300px; /* background: black; */ border: 1px solid black; color:gray; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li id="1" draggable="true"&gt;1&lt;/li&gt; &lt;li id="2" draggable="true"&gt;2&lt;/li&gt; &lt;li id="3" draggable="true"&gt;3&lt;/li&gt; &lt;li id="4" draggable="true"&gt;4&lt;/li&gt; &lt;li id="5" draggable="true"&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;div class="wrapper"&gt;删除列表项&lt;/div&gt; &lt;script src="./jquerymin.js" &gt;&lt;/script&gt; &lt;script&gt; var li = document.getElementsByTagName('li'); var wrapper = document.getElementsByClassName('wrapper')[0]; var ul = document.getElementsByTagName('ul')[0]; for(var i = 0;i &lt; li.length;i++)&#123; var index = getIndex(this); li[i].addEventListener('dragstart',function(e)&#123; e.dataTransfer.setData('data',this.id); &#125;); li[i].addEventListener('dragover',function(e)&#123; e.preventDefault(); &#125;); li[i].addEventListener('drop',function(e)&#123; var data = e.dataTransfer.getData('data'); console.log(this.id); console.log(data); ul.insertBefore(this,document.getElementById(data)); // li[i].insertBefore(); &#125;); &#125; function getIndex(dom)&#123; for(var i = 0;i &lt; li.length;i++)&#123; if(li[i] === dom)&#123; return i; &#125; &#125; &#125; wrapper.addEventListener('dragenter',function()&#123; &#125;) wrapper.addEventListener('dragover',function(e)&#123; e.preventDefault(); &#125;) wrapper.addEventListener('drop',function(e)&#123; e.preventDefault(); var data = e.dataTransfer.getData('data'); ul.removeChild(document.getElementById(data)); console.log(data); &#125;) 效果： 文件读取FileReader方法终止读取abort() 不同读取文件方法readAsBinaryString(file) 将文件读取为二进制编码 readAsDataURL(file) 将文件读取为DataURL编码 readAsText(file,[encoding])将文件读取为文本 readAsArrayBuffer(file)将文件读取为arraybuffer FileReader事件onloadstart 读取开始时触发 onprogress读取中触发 onloadend 读取完成触发，无论成功或者失败 onload文件读取成功时触发 onabort 中断时触发 onerror出错时触发 相关练习三个 Web Socket概念WebSocket对象提供了一组API，用于创建和管理Websocket的连接，以及通过连接发送和接收数据。 websocket其实是一个新协议，和HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范，借用了HTTP协议来完成握手。 Web Socket产生原因 在 HTTP/1.0 中,默认非长链接大多实现为每个请求/响应交换使用新的连接，即并非长久连接，在 HTTP/1.1 中,默认长连接一个连接可用于一次或多次请求/响应交换，这种连接方式相对更消耗服务器资源 HTTP协议中，服务端不能主动联系客户端，只能有客户端发起，而webSoket服务器和客户端均可主动发送数据 Web Socket建立连接的过程​ 当Web应用程序调用new WebSocket(url)接口时，Browser就开始了与地址为url的WebServer建立握手连接的过程。 Browser与WebSocket服务器通过TCP握手建立连接，如果这个建立连接失败，那么后面的过程就不会执行，Web应用程序将收到错误消息通知。 在TCP建立连接成功后，Browser通过http协议传送WebSocket支持的版本号，协议的字版本号，原始地址，主机地址等等一些列字段给服务器端。 WebSocket服务器收到Browser发送来的请求后，如果数据包数据和格式正确，客户端和服务器端的协议版本号匹配等等，就接受本次握手连接，并给出相应的数据回复，同样回复的数据包也是采用http协议传输。 Browser收到服务器回复的数据包后，如果数据包内容、格式都没有问题的话，就表示本次连接成功，触发onopen消息，此时Web开发者就可以在此时通过send接口向服务器发送数据。否则，握手连接失败，Web应用程序会收到onerror消息，并且能知道连接失败的原因。 请求头和响应头Request Headers12345678- GET /chat HTTP/1.1- Host: server.example.com- Upgrade: websocket- Connection: Upgrade- Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==- Sec-WebSocket-Protocol: chat, superchat- Sec-WebSocket-Version: 13- Origin: http://example.com 在这段类似http协议的的握手请求中多了一些东西： 12- Upgrade: websocket- Connection: Upgrade 这两行是websocket的核心，它负责告诉服务器，将协议升级成websocket，并且找到与之对应的服务助理 123- Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==- Sec-WebSocket-Protocol: chat, superchat- Sec-WebSocket-Version: 13 第一行Sec-WebSocket-key 是一个Base64的值，是浏览器随机生成的，用来验证找到的服务助理是否是websocket协议的。 第二行Sec-WebSocket-Protocol 是用户定义的字符串，用来区分同URL下，不同服务所需要的协议。 最后一行，是告诉服务器所使用的websocket Draft（协议版本） Response Headers12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 当服务器返回以上内容时，表名它已经接到请求，并成功建立连接 12Upgrade: websocketConnection: Upgrade 这两行同样是告诉客户端即将升级的是websocket协议。 Sec-WebSocket-Accept 是经过服务器确认，并且加密后的Sec-WebSocket-Key Sec-WebSocket-Protocol则表示最终使用的协议 Web Socket方法socket.send()send(data) 方法使用连接传输数据。 语法： 1234var Socket = new WebSocket('ws://echo.websocket.org/');Socket.onopen = function()&#123; Socket.send('hello');&#125; WebSocket.org 提供了一个专门用来测试WebSocket的服务器”ws://echo.websocket.org” Socket.close()close() 方法用于终止任何现有连接 1234Socket.onmessage = function()&#123; Socket.close(); //关闭后，服务器不再接受任何信息。&#125; Web Socket事件 事件 事件处理程序 描述 open Socket.onopen 建立Socket连接时触发该事件 message Socket.onmessage 客户端从服务端接收数据时触发 error Sockent.onerror 连接错误时触发 close Sockent.onclose 连接被关闭时触发 demo： 12345678910111213var Socket = new WebSocket('ws://echo.websocket.org/'); Socket.onopen = function()&#123; Socket.send('hello'); &#125; Socket.onmessage = function(e)&#123; console.log(e); console.log(e.data); Socket.close() Socket.send('hello'); &#125; Socket.onclose = function()&#123; console.log('close'); &#125; Web Socket优点 1.客户端与服务器都可以主动传送数据给对方; 2.不用频率创建TCP请求及销毁请求，减少网络带宽资源的占用，同时也节省服务器资源; ECharts概念教程渐进增强 优雅降级]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3响应式布局]]></title>
    <url>%2F2018%2F08%2F19%2Fcss3_5%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[响应式布局为了实现兼容不同屏幕分辨率、清晰度以及屏幕定向方式竖屏(portrait)、横屏(landscape)下弹性适应，我们使用了响应式布局的防滑，利用媒体查询方法实现向不同设备提供不同样式。接下来将介绍具体的响应式布局方法的做法： meta标签定义 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。 属性 属性 意义 name 把content的属性关联到HTTP头部 content 定义与 http-equiv 或 name 属性相关的元信息，content值始终要和name或http-equiv一起使用 http-equiv 该属性为名称/值对提供了名称。并指示服务器在发送实际的文档之前在要传送的给浏览器的MIME文档头部包含名称/值对 媒体查询 媒体查询是向不同设备提供不同样式的一种方式，它为每种类型的用户提供了最佳的体验。 css2和css3媒体查询css2:media type 在css2中，通过media type （媒体类型）我们可以对不同的设备指定特定的样式，从而实现更加丰富的界面 css3:media query css3中media query 是对媒体类型的增强，可以把media query 看成media type + css属性（媒体特性 Media features）判断 media typed的引用方法link 引入1&lt;link rel="stylesheet" media="screen and (max-width:800px)" href="index.css"&gt; @importcss3新增的@media123456789101112131415@media screen and(max-width: 800px)&#123; div&#123; width: 100px; height: 100px; background:green; &#125;&#125;@media screen and(min-width: 801px;)&#123; div&#123; width:100px; height: 100px; background:orange; &#125;&#125; 效果： 媒体类型 类型 解释 all 所有设备 Braille 盲文 embossed 盲文打印 handheld 手持设备 print 文档打印或打印预览模式 projection 项目演示，如幻灯片 screen 彩色电脑屏幕 speech 演讲 tv 电视 媒体特性 逻辑操作符and1@media screen and (min-width: 600px) and (max-width:100px) 合并多个媒体属性或合并多个媒体类型，一个基本的媒体查询，即一个媒体属性与默认指定的screen媒体类型 ，指定备用功能1@media screen and (min-width: 769px), print and (min-width: 6in)" 没有or关键词可用于指定备用的媒体功能。相反，可以将备用功能以逗号分割列表的形式列出这会将样式应用到宽度超过769像素的屏幕或使用至少6英寸宽的纸张的打印设备。 not 指定否定条件1@media not screen and (monochrome) 要指定否定条件，可以在媒体声明中添加关键字not，不能在单个条件前使用not。该关键字必须位于声明的开头，而且它会否定整个声明。所以，上面的示例会应用于除单色屏幕外的所有设备。 * only1@media="only screen and (min-width: 401px) and (max-width: 600px)" 容易混淆的宽度device-width/height 是设备的宽度（如电脑手机的宽度 不是浏览器的宽度） width/height 使用documentElement.clientWidth/Height即viewport的值。 图片像素 一个网站能够兼容多个终端，而不是为每个终端做一个特定的版本，这个概念是为了解决移动互联网而诞生的。 响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验。 物理像素和设备独立像素一个物理像素是显示器上最小的物理显示单元，在操作系统的调度下，每个设备像素都有自己的颜色值和亮度。 设备独立像素（目睹无关像素）可以认为是计算机系统中的一个点，这个点代表一个可以由程序使用的一个虚拟像素（css）像素，然后由相关系统转换成物理像素。 设备像素比（device pixel ratio）简称dpr ，dpr定义了物理像素和设备独立像素的对应关系，它的值有一下公式得出： dpr = 物理像素 / 设备独立像素 在js中可以通过window.devicePixelRatio得到。 例：一台iPhone6的宽高我375667 ，则他的设备独立像素则为375 667 ，而她的dpr=2,那么其物理像素则为设备独立像素2，即750 1334。 当dpr = 2 时，表示一个css像素在PC端显示器需要用（1*1 ）个栅格点，在iPhone6中则需要4个。 也就是说在不同的屏幕中（普通屏幕vs retina屏幕），css像素所呈现的大小（物理尺寸）是一致的，但每个css对应的物理像素个数是不一样的。 所以对于这种一个css像素对应四个物理像素的情况，css像素不能被分隔，物理像素只能就近取色，从而导致图像会变得模糊 右边为物理像素，四个物理像素本来应该是都是#298fe2色号，但由于就近取色的原因，只有一个物理像素能拿到真正的颜色，其他像素则是就近取，这样就导致了图片模糊。 解决办法： 增大图片的分辨率为原来的两倍，这样位图像素点的个数就变为原来的四倍，那么就能保证一个css像素对应一个物理像素，从而精准的get到正确的颜色 但这也会出现新的问题，那就是图片在普通屏幕下，dpr=1,也就是说，一个物理像素正好对应一个css像素，但由于分辨率增大了，则会产生1个物理像素对应四个css像素的情况，所以这时候物理像素的取色也会根据一定算法去显示，不会模糊，但会使图片产生一定色差。 Retina标准Retina 屏幕：所谓“Retina”是一种显示标准，是把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度。由摩托罗拉公司研发。最初该技术是用于Moto Aura上。这种分辨率在正常观看距离下足以 使人肉眼无法分辨其中的单独像素。也被称为视网膜显示屏。 1个位图像素是栅格图像（如：png，jpg，gif等）最小的数据单元。每一个位图像素都包含这一些资深的现实信息（如：显示位置，颜色值，透明度等）e 在普通屏幕下是没问题的，但是在retina屏幕下就会出现位图像素点不够，从而导致图片模糊的情况 浏览器渲染原理渲染原理1.处理html生成dom树 浏览器把获取到的html代码解析成一个dom树，html中每个tag都是一个节点，根节点就是html,这些节点也包括js动态生成的节点。生成dom树的过程也叫元素节点的解析，（注意不 是加载，解析和加载是异步的过程）当有image的节点时，不等它下载好图片，而是先把image的名字挂到dom树上。 2.处理css生成cssom树 浏览器会把所有样式（包括css样式和浏览器默认样式）解析成样式结构体，在解析过程中会去掉浏览器不能识别的样式，生成cssom树。 3.把两棵树合并生成render树 rendertree不包含隐藏的节点（如：display：none的节点，还有无样式的head节点）因为这些节点不会用于呈现，不会影响呈现，但是类似visibility：hidden这类被隐藏的节点还是会挂到rendertree上的，因为它占据了空间。 4.对render树进行布局计算 rendertree构建完毕后，会根据样式计算布局，在布局阶段给出的结果叫做盒模型。盒模型精准的表达了节点元素的位置和大小，而且所有的相对度量单位都会转化成了屏幕上的绝对像素位置（rendertree上每一个节点都可称为一个box（盒模型）） 5.将render树上的每一个节点都绘制到屏幕上 将这些信息渲染为屏幕上每个真实的像素点了。这个阶段称为“绘制”，或者“栅格化”（rasterizing） 重排、重绘重排： 当rendertree中一部分或全部因为元素的尺寸、布局、隐藏等改变而需要重新构建。我们计算它们在当前设备中准确的位置和尺寸。这正是布局阶段要做的的工作，该阶段在英语中也被称为“回流”（reflow） 触发重排的属性： offsetTop、offsetLeft、 offsetWidth、offsetHeight；scrollTop、scrollLeft、scrollWidth、scrollHeight；clientTop、clientLeft、clientWidth、clientHeight；dom节点的删除、增加、尺寸和位置变化等 触发重排的方法 getComputedStyle() 、currentStyle（） 重绘： 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 重绘，重排会影响性能 蓝色：网络通信和HTML解析 黄色：JavaScript执行 紫色：样式计算和布局，即重排 绿色：重绘 优化为了提高网页性能，降低重排和重绘的成本，浏览器会维护一个队列，把所有会引起重绘和重排的操作都放到一个队列里，等队列中的操作到了一定时间或者数量的时候，浏览器就会flush队列，进行一个批处理。这样会让多次的重排重绘变成一次重排（回流）重绘。这是浏览器本身的优化策略。 但是有时候我们写的一些代码，会强制的让浏览器提前flush队列，这样浏览器的优化就起不了作用了。（比如当你请求一些style信息的时候） 所以我要尽量利用好浏览器的优化策略，减少对rendertree的操作和对style信息的请求。 一些优化方法： 将多次改变样式属性的操作合成一次操作 将需要多次重排的元素的position定位设置成absolute或者fixed，这样元素就会脱离文档流，而不会影响其他元素的位置，例如一些有动画效果的元素就可以设置成绝对定位 在内存中多次操作节点，完成后，再将其一并添加到文档中去，比如要异步请求一组数据并将其绘制成表格，则可以先把数据请求到之后再在内存中构建出整个表格再添加到html中去（如:以前写的扫雷游戏中的棋盘绘制 由于display属性为none的元素不在渲染树中，所以对这类隐藏的元素操作不会引起其他元素的重排。所以，如果要对一个元素进行复杂操作时，可以先将其display设置成none，在等操作完成时再显示出来，这样只会在隐藏和显示时触发两次重排 对于要取经常引起重排的元素，可以先将其缓存到变量中。（var dom = document.getElementsByClassName(‘div’)）;)]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3布局]]></title>
    <url>%2F2018%2F08%2F19%2Fcss3_4%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[columns 多列布局​ 为了能在Web页面中方便实现类似报纸、杂志那种多列排版的布局，W3C特意给CSS3增加了一个多列布局模块（CSS Multi Column Layout Module）。它主要应用在文本的多列布局方面，这种布局在报纸和杂志上都使用了几十年了，但要在Web页面上实现这样的效果还是有相当大的难度，庆幸的是，CSS3的多列布局可以轻松实现。 语法：columns: [column-width、 column-count]; column-width指每一列的宽度 根据容器宽度自适应 （最小宽度） column-count指规定的列数 唯一精准的是列数 不要两个一起使用 会乱 column-gap设置列与列之间的宽度，直接用数值表示即可(eg:10px) 主要用来设置列与列之间的间距 如果没有显示设置column-gap值时，其值大小会根据浏览器默认的 font-size（默认是16px）来定 column-rule占用任何空间位置的，在列与列之间改变其宽度不会改变任何列的位置。 column-rule-width:宽度，类似于border-width属性，主要用来定义列边框的宽度，其默认值为“medium”。 column- rule-width 属性接受任意浮点数，但不接收负值。 但也像border-width属性一样，可以使用关键词：medium、thick和thin。 column-rule-style样式，类似于border-style属性，主要用来定义列边框样式，其默认值为“none”。 column-rule-style属性值与border-style属值相同，包括none、hidden、dotted、dashed、solid、double、groove、ridge、inset、outset column-rule-color 颜色 类似于border-color属性 column-span: 语法：.box{column-span:1||all;} 设置多列布局元素内的子元素，可以跨列，类似标题效果。即一个新闻标题要横跨所有内容列。注：此属性要在子元素上设置。 eg: 123.wrapper&#123; column-span:all;&#125; 盒模型在css中盒模型被分为两种，第一种是w3c的标准盒模型，另一种是IE6混杂模式的传统模型。他们都是对元素计算尺寸的模型。但他们的不同是计算的方式不同。 W3C标准盒模型element空间高度（盒子） = width + padding + border; width 为内容高度。即width不包括padding 和 border IE6混杂模式盒模型内容高度 （盒子）= width - padding - border 即 设置width的数值就是element 的空间高度，width包含padding 和border box-sizing属性border-box/content-box content-box为W3C标准盒子 border-box为IE6混杂模式的盒子 弹性盒子flex为复核属性，且必须配合父元素display:flex 或者使用 eg: 12345678910111213141516171819202122232425262728293031&lt;style&gt; body&#123; font-size: 0%; &#125; .wrapper&#123; display: flex; width: 500px; height: 500px; border: 1px solid #000; &#125; .item&#123; display: inline-block; width: 200px; text-align: center; height: 30px; line-height: 30px; border:1px solid #000; box-sizing: border-box; font-size: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 没有这个属性时： 添加 display:flex 后 flex属性flex-grow 根据所设置的比例分配盒子所剩余的空间拓展：左右两栏布局默认值为0； eg： 1234567891011121314151617181920212223.item&#123; display: inline-block; width: 50px; /*attention here 这里的width是50*/ text-align: center; height: 30px; line-height: 30px; border:1px solid #000; box-sizing: border-box; font-size: 20px; flex-grow: 1; &#125; .item:nth-of-type(1) &#123; flex-grow: 1; &#125; .item:nth-of-type(2) &#123; flex-grow: 2; &#125; .item:nth-of-type(3) &#123; flex-grow: 2; &#125; /*会将三个item按照1:2:2的比例放进弹性项目里*/ flex-shrink 缩小比例–多出盒子的部分，按其所设置的比例砍掉相应的大小，比例越大砍的越大，默认值是1； (flex-shrink1 width1)/( flex-shrink X width1 + flex-shrink2 X width2 ) morewidth(超出的宽度，下面的demo超出的宽度是200px) eg： 1234567891011121314151617181920212223242526272829.wrapper&#123; display: flex; width: 400px; height: 500px; border: 1px solid #000; &#125; .item&#123; display: inline-block; width: 200px; text-align: center; height: 30px; line-height: 30px; border:1px solid #000; box-sizing: border-box; font-size: 20px; /* flex-grow: 1; */ &#125; .item:nth-of-type(1) &#123; /* width:200px; */ flex-shrink:1; &#125; .item:nth-of-type(2) &#123; /* flex-grow: 2; */ flex-shrink: 1; &#125; .item:nth-of-type(3) &#123; /* width:200px; */ flex-shrink: 0; &#125; flex-basis 伸缩基准值.项目占据主轴的空间，该属性可设置元素的宽度或者高度，width也可以用来设置元素宽度，如果元素上同时出现width和flex-basis 那么flex-basis会覆盖width的值 eg:12345678910&gt; .wrapper&#123;&gt; &gt; &#125;&gt; .item&#123;&gt; flex-basis: 200px;&gt; height:30px;&gt; width:100px;&gt; /* 此时主轴方向是默认x轴，所以这时width是200px,不是100px*/&gt; &#125;&gt; 主轴的方向可以变 ——&gt; 12345678910&gt; .wrapper&#123; &gt; flex-direction:column; &gt; /* 垂直方向*/&#125;&gt; .item&#123; &gt; flex-basis: 100px; &gt; height:30px; &gt; width:100px; &gt; /* 此时主轴方向是y轴，所以这时height是100px,width是100px*/&gt; &#125;&gt; 子元素宽度尽可能的按照basis来，如果基准值相加大于容器宽度，那么，则由公式分配宽度给子元素 （flex-basis/(flex-basis相加)）*容器的宽度 flex是flex-grow, flex-shrink 和 flex-basis的简写 order排列顺序,根据子元素order从小到大的顺序排列，order可以是负数。 align-self单个项目对齐方式，它允许单个项目有不一样的对齐方式，它可以覆盖align-item属性，默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 align auto 默认，挨着容器最上面 flex-start 在容器开始的位置排序 flex-end 使当前项目在最下面开始排序 center 在容器中间排序 baseline 基准线—设置基准线后使每个项目按照这个基准线排序 stretch 如果没有给子元素设置高度，则默认继承父级容器的高度 baseline：如果子元素没有内容，子元素的底部和其他子元素的文字齐平。 弹性盒子提供的一些属性 应该设置在父级元素上的属性 flex-direction该属性决定主轴的方向，即项目的排列方向 值分类 属性解释 row(默认值) 主轴为水平方向 row-reverse 主轴为水平方向，由终点向起点方向方向 column 主轴为垂直方向，起点在上沿 column-reverse 主轴为垂直方向，起点是从下往上 flex-wrap 默认情况下，项目都排在一条轴线上。flex-wrap则负责定义，如果一条轴线排不下，如何换行 值 意义 nowrap（默认） 不换行 wrap 换行，第一行在上方 wrap-reverse 换行，第一行在下方 flex-flowflex-flow是flex-direction和flex-wrap简写的形式 .box{ flex-flow:flex-direction || flex-wrap ;} .box{flex-flow:row wrap;} justify-content定义了项目在主轴上的对齐方式 主轴由flex-direction来确定，当没有设置的时候，默认为水平方向 属性值 定义 flex-start（默认值） 左对齐 flex-end 右对齐 center 居中 space-between 两端对齐，项目之间的间隔都相等 space-around 每个项目两边的间距是相等 123456789101112131415161718.wrapper&#123; display: flex; width: 800px; height: 500px; border: 1px solid #000; justify-content:space-around; &#125; .item&#123; display: inline-block; width: 200px; text-align: center; height: 30px; line-height: 30px; border:1px solid #000; box-sizing: border-box; font-size: 20px; /* flex-grow: 1; */ &#125; center: space-between： 123456.wrapper&#123; justify-content:space-between;&#125;.box&#123; .....&#125; space-around: align-items定义项目在侧轴上如何对齐,它可能取5个值，具体的对齐方式与交叉轴的方向有关 假设交叉轴从上到下，得出属性 这里的侧轴是相对于主轴来说的，而主轴是由flex-direction决定的，即当主轴是水平的，侧轴则是垂直的，当主轴是垂直的，侧轴则是水平的 属性值 属性意义 flex-start 交叉轴的起点对齐 flex-end 交叉轴的终点对齐 center 交叉轴的中间对齐 baseline 项目的第一行文字基线对齐 stretch（默认） 如果项目未设置高度或者是auto，项目将占满整个容器的高度 12345.wrapper&#123; display:flex; flex-direction:row; align-items:flex-end;&#125; align-content定义了多根轴线的对齐方式，如果项目只有一根轴线则该属性不起作用，属性可取6个值 属性值 意义 flex-start 交叉轴的起点对齐 flex-end 交叉轴的终点对齐 center 交叉轴的中间对齐 space-between 与交叉轴两端对齐，轴线之间的间隔平均分布 space-around 每根轴线两侧的间隔都相等，所以轴线之间的间隔比轴线边框的间隔大一倍 stretch(默认) 轴线占满整个交叉轴 eg:写一水平垂直居中的弹性盒子 1234567891011121314151617181920212223242526272829303132333435363738&lt;style&gt; body&#123; display:flex; width:100%; height:100%; justify-content:center; align-items: center; &#125; .wrapper&#123; display: flex; /* flex-direction: row; */ flex-wrap:wrap; width: 500px; height: 500px; border: 1px solid #000; align-content:space-around; /* align-items: flex-start; */ &#125; .item&#123; display: inline-block; width: 200px; text-align: center; height: 30px; line-height: 30px; border:1px solid #000; box-sizing: border-box; font-size: 20px; /* flex-grow: 1; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 效果： 定义一个弹性盒子 display:flex 或者 display:inline-flex; 这样就能够将元素定义为一个弹性容器，使其子元素成为弹性项目，flex使弹性容器成为一个块级元素，而inline-flex使弹性容器成为单个不可分的行内级元素 不影响弹性盒子的属性 由于弹性盒子使用了不同的布局算法，某些属性在弹性容器上没有意义： 多栏布局模块的column-*属性对弹性项目无效。 float与clear对弹性项目无效。使用float将使元素的 display属性记为block vertical-align对弹性项目无效###css3其他的新属性 transparent transparent是颜色的透明色。 eg:用css3的Transparent值画一个三角形 123456789101112&lt;style&gt; .demo&#123; width: 0; height: 0; border: 100px solid black; border-left-color:transparent; border-right-color: transparent; border-top-color: transparent; box-sizing:border-box; &#125;&lt;/style&gt;&lt;div class="demo"&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3动画]]></title>
    <url>%2F2018%2F08%2F19%2Fcss3_3%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[CSS3动画transform transform属性向元素应用2D或3D转换，该属性允许我们对元素进行旋转，缩放、移动或者倾斜 transform中主要的方法旋转 ​ 可以实现元素的形状、角度、位置等的变化。 rotate() 2D旋转，在括号中填写参数规定旋转的角度。 demo: 123456789101112131415161718&gt; &lt;style&gt;&gt; div&#123;&gt; position: relative;&gt; width: 100px;&gt; height: 100px;&gt; top: 100px;&gt; left: 100px;&gt; background: orange;&gt; transform:rotate(30deg);&gt; &#125;&gt; &lt;/style&gt;&gt; &lt;/head&gt;&gt; &lt;body&gt;&gt; &lt;div&gt;&gt; demo&gt; &lt;/div&gt;&gt; &lt;/body&gt;&gt; 效果： rotatex() 实现3D旋转，使元素绕x轴旋转给定的角度。 rotatey()rotatez()rotate3d(x, y, z, angle) rotate3d(x,y,z,angle) 前三个参数相当于在x,y,z三个方向上的力找一个合力的方向，以这个方向为轴线，顺时针（值是正数）旋转angle个角度,注意理解前三个参数是矢量值，如：当x !=0,y=z=0时，不管x=多少，元素都是在x轴方向进行旋转角度。 如： 1234567891011121314151617181920&lt;style&gt; .demo&#123; width:200px; height:200px; border:1px solid black; transform-style:preserve-3d; perspective:300px; &#125; .aa&#123; widtt:100px; height:100px; background:orange; transform:rotate3d(0.5,0,0,45deg); &#125;&lt;/style&gt;&lt;div class="demo"&gt; &lt;div class="aa"&gt; &lt;/div&gt;&lt;/div&gt; 缩放scale() 以x/y为轴进行缩放 scale(x, y) 接受两个值，如果第二参数未提供，则第二个参数使用第一个参数的值 scalex()scaley() 值是数字表示倍数，不加任何单位 dom元素中的内容也会跟着缩放，如果是负数，如果是-0.5则效果： scalez()scale3d() scale3d(sx,sy,sz) 倾斜skew() 对元素进行倾斜扭曲 skew(x, y);接受两个值，第一个参数对应X轴，第二个参数对应Y轴。 如果第二个参数未提供，则默认值为0, skewx()skewy()平移translate()可以移动距离,相对于自身位置。 translate(x, [y])translatex()填百分号则表示沿x轴平移自身高度的百分比 translatey()translatez()translate3d(x, y, z)transform-origin 变换原点含义：定义了视图的中心，视图中心 语法: 1transform-origin: x-axis y-axis z-axis; 任何一个元素都有一个中心点，默认情况下，其中心点是居于元素x轴和y轴的50%处. 取值 transition 过渡动画eg: 123456789101112131415.demo&#123; position: absolute; left: 0px; width: 100px; height:100px; background: red; transition: width 2000ms linear 1s; /* 四个参数意义：指定过渡属性--transition-property 指定过渡所需时间--transition-duration 指定过渡函数--transition-timing-funcition 指定开始出现的延迟时间---transition-delay */ &#125; .demo:hover&#123; width: 300px; &#125; 相关属性 transition 属性是css3的一个复合属性，主要包括一下几个子属性 transition-property指定过渡或动态模拟的css属性 transition-duration指定过渡所需要的时间 transition-timing-function指定过渡函数 transition-delay指定开始出现的延迟时间 transition 过渡动画可以参与过渡的属性 transition-function速率函数可以选择的值 animation 动画铺垫动画关键帧 @keyframes animation 动画会按照keyframes 关键帧里面指定的帧状态而过渡执行。 0% - 100% 代表动画的时间过渡 123456789101112131415161718192021.demo1&#123; position: absolute; left: 0px; top: 30px; width: 100px; height:100px; background:red; animation: move 4s linear both; &#125; @keyframes move&#123; 0%&#123; background:red; left:200px; &#125; 100%&#123; background:green; left: 600px; &#125; &#125; 帧频里面如果只有 0% 和 100%两个关键帧，那么可以用 from to 代替 如果from时的状态和初始默认的状态一致的话也可以省去from关键帧，直接写to关键帧 animation相关属性animation 属性为css3的复合属性，主要包括以下子属性 animation-name:此属性为执行动画的 keyframe 名 animation-duration此属性为动画执行的时间 animation-timing-function指定过渡函数速率 animation-delay执行延迟时间 animation-direction属性主要用来设置动画播放方向 animation-direction值 意义 normal 默认值。动画按正常播放。 reverse 动画反向播放。 alternate 动画在奇数次（1、3、5…）正向播放，在偶数次（2、4、6…）反向播放。 alternate-reverse 动画在奇数次（1、3、5…）反向播放，在偶数次（2、4、6…）正向播放 animation-iteration-count属性主要用来定义动画的播放次数。 animation-iteration-count 意义 infinite n 播放次数 number infinite 无限次 animation-fill-mode 属性定义在动画开始之前和结束之后发生的操作。主要具有四个属性值： animation-fill-mode 意义 none 默认值，表示动画将按预期进行和结束，在动画完成其最后一帧.时，动画会反转到初始帧处 forwards 表示动画在结束后继续应用最后的关键帧的位置 backwards 会在向元素应用动画样式时迅速应用动画的初始帧（结合延迟1s来看） both 元素动画同时具有forwards和backwards效 animation-play-state 属性主要用来控制元素动画的播放状态。 ​ running 播放 ​ paused 暂停 ​ demo : 纵向排列照片墙]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 3D动画]]></title>
    <url>%2F2018%2F08%2F19%2Fcss3_3_3d%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[css3D动画transform-styleflat : 默认属性，子元素将不保留其3D位置； preserve-3d ：子元素将保留其3D位置。 transform-style需要设置在父元素当中，高于任何嵌套的变形元素 当设置了preserve-3d时，就不能为了防止其溢出而设置overflow：hidden了，这样会导致preserve-3d失效 perspective 景深 景深（英语：Depth of field, DOF）景深是指相机对焦点前后相对清晰的成像范围。在光学中，尤其是录影或是摄影，是一个描述在空间中，可以清楚成像的距离范围。虽然透镜只能够将光聚到某一固定的距离，远离此点则会逐渐模糊，但是在某一段特定的距离内，影像模糊的程度是肉眼无法察觉的，这段距离称之为景深。当焦点设在超焦距处时，景深会从超焦距的一半延伸到无限远，对一个固定的光圈值来说，这是最大的景深。 。。。。。。。TOT 。。。。什么鬼 景深可以理解成肉眼距离显示器的距离，景深越大，我们所看到的就越“远”，效果就会不好。 在css中，景深相当于激活了一个3D的空间，我们可以利用translateZ来辅助理解景深这个概念 比如此时有一个长宽为100px的div，它的景深为300px，即人眼离显示器的距离为300px；当我们利用translateZ来变换div在z轴上的位置（垂直于浏览器的位置）时，人眼的感觉是近大远小，而将div的translateZ的值增大到299px时，（也就是这玩意儿怼到你眼前了）而当他到了300px时，他就相当于跑到你眼睛后边儿去了所以你它就不在了。 如： 123456789101112131415161718192021 &lt;style&gt; .wrapper&#123; position: absolute; transform-style: preserve-3d; perspective: 300px; &#125; .content&#123; width: 100px; height: 100px; position: relative; background-color:orange; transform:translateZ(20px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="content"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 效果： 当这个div再往前怼一个px的时候它就在你的视网膜后边儿了你就看不到了 所以说景深是css中实现3d效果的重要属性 我们再举个栗子！ 1234567891011121314151617181920212223 &lt;style&gt; .wrapper&#123; width: 100px; height: 100px; border: 1px solid black; position: absolute; transform-style: preserve-3d; /* perspective: 300px; */ &#125; .content&#123; width: 100px; height: 100px; position: relative; background-color:orange; transform:rotateX(45deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;/div&gt; 没有添加景深时，div绕x轴旋转的效果： 添加了景深时：（perspective：300px；） 现在景深这个词意义能够理解了吧~小陈 perspective-originx，y （center /left/ right/%,center/top/bottom/%） 指在父元素中x、y轴方向上的源点位置 50% 50% 默认值，子元素的源点在父元素的中心，也可表示成center center perspective-origin属性是3D变形中另一个重要属性，主要用来决定perspective属性的源点角度。它实际上设置了X轴和Y轴位置(或者说基点)，在该位置观看者好像在观看该元素的子元素。（可以理解成，人从哪个角度看过去） 比如：当perspective-origin为默认值时，视觉上平视过去的，所以当一个元素绕x轴旋转到90度时（rotateX（90deg）），我们就看不到他了，旋转到89度时只能看到一条线，如： 如果这是我们将perspective-origin属性值改成：top时，效果如下： 相当于是我们从上帝视角看它啦哈哈哈 transform:pespective()除了有perspective属性以外还有perspective函数，属性可以用在舞台元素上，也就是变形元素们的父元素，这时只有一个透视点，所以越往下的图片，我们的“俯视角”越大，看到的就越多。如下： 123456789101112131415161718.wrapper&#123; border:1px solid gray; position: absolute; transform-style: preserve-3d; perspective: 200px; &#125; .wrapper div &#123; width: 100px; height: 100px; border:1px solid gray; /* position: absolute;; */ background-color:orange; /* opacity: 0.7; */ transform:rotateX(45deg); &#125; 但是将perspective(300px)设置在 div下即 123.wrapper .div&#123; transform:perspective(600px) rotateZ(45deg);&#125; 这时每个元素都有一个透视点，所以图片的样子都是一样的，如： backface-visibility 属性值 意义 visible 当元素翻面的时候，背面可见。默认值 hidden 背面隐藏 关于3D旋转当元素在旋转的时候，坐标轴也在跟着旋转 例： 123456789101112131415.item1&#123; position: absolute; width: 100px; height: 100px; background: orange; transform: rotateX(90deg) translateZ(50px);&#125;.item2&#123; position: absolute; width: 100px; height: 100px; background: green; transform: rotateX(-90deg) translateZ(100px);&#125; 两个item的距离应是150px demo1：3D旋转展示照片 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768*&#123; margin:0; padding:0;&#125;.wrapper&#123; width: 300px; height: 300px; margin: 0 auto; margin-top:100px; position: relative; perspective: 600px; perspective-origin: top ; /* transform: rotateX(20deg); */&#125;.wrapper .demo&#123; position: absolute; width: 200px; height: 200px; left: 50%; top: 50%; transform-style: preserve-3d; animation: move 4s linear both ; animation-iteration-count: infinite; &#125;@keyframes move&#123; 0%&#123; transform:translate(-50%,-50%) rotateY(0deg) ; &#125; 100%&#123; transform:translate(-50%,-50%) rotateY(360deg) ; &#125;&#125;.wrapper .demo div&#123; position: absolute; width: 200px; height: 150px; opacity: 0.8; line-height: 100px; text-align: center; color: white;&#125;.item1&#123; background:orange ; transform: translateZ(200px); &#125;.item2&#123; transform: rotateY(60deg) translateZ(200px); background:green;&#125;.item3&#123; transform: rotateY(120deg) translateZ(200px); background:deepskyblue;&#125;.item4&#123; transform: rotateY(180deg) translateZ(200px); background:deeppink;&#125;.item5&#123; transform: rotateY(240deg) translateZ(200px); background:purple;&#125;.item6&#123; transform: rotateY(300deg) translateZ(200px); background:red;&#125; 123456789101112&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="demo"&gt; &lt;div class="item1"&gt;1&lt;/div&gt; &lt;div class="item2"&gt;2&lt;/div&gt; &lt;div class="item3"&gt;3&lt;/div&gt; &lt;div class="item4"&gt;4&lt;/div&gt; &lt;div class="item5"&gt;5&lt;/div&gt; &lt;div class="item6"&gt;6&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 其实它还会旋转 是我无能了 传不上来gif T0T demo2:旋转立方体 12345678&lt;div class="wrapper"&gt; &lt;div class="item1"&gt;&lt;/div&gt; &lt;div class="item2"&gt;&lt;/div&gt; &lt;div class="item3"&gt;&lt;/div&gt; &lt;div class="item4"&gt;&lt;/div&gt; &lt;div class="item5"&gt;&lt;/div&gt; &lt;div class="item6"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263*&#123; margin: 0; padding: 0;&#125;.wrapper&#123; position: relative; width: 200px; height: 200px; top: 100px; /* border: 1px solid black; */ margin: 0 auto; transform-style:preserve-3d; /* perspective: 300px; */ /* perspective-origin: left ; */ animation: move 5s linear infinite both;&#125;@keyframes move&#123; 0%&#123; transform: rotate3d(1,1,1,0deg); &#125; 100%&#123; transform: rotate3d(1,1,1,360deg); &#125;&#125;.wrapper div&#123; top: 25%; left: 25%; /* transform: translate(-50%,-50%); */ width: 100px; height: 100px; position: absolute; opacity: 0.7; &#125;.item1&#123; background: orange;&#125;.item2&#123; transform-origin: left center; background: green; transform: rotate3d(0,1,0,90deg);&#125;.item3&#123; background: rebeccapurple; transform-origin: right center; transform: rotate3d(0,1,0,-90deg);&#125;.item4&#123; background: deeppink; transform-origin: bottom ; transform: rotate3d(1,0,0,90deg);&#125;.item5&#123; background: deepskyblue; transform-origin: top center; transform: rotate3d(1,0,0,-90deg); &#125;.item6&#123; transform-origin: right center; transform: translate3d(0,0,-100px); background: red ;&#125; 效果：]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3选择器]]></title>
    <url>%2F2018%2F08%2F19%2Fcss3_2%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[CSS3选择器属性选择器 方式 意义 E[att^=“val”{…} 选择匹配元素E, 且E元素定义了属性att, 其属性值以val开头的任何字符串 E[att$=“val”{…} 选择匹配元素E, 且E元素定义了属性att, 其属性值以val结尾的任何字符串 E[att*=“val”{…} 选择匹配元素E, 且E元素定义了属性att, 其属性值任意位置出现了“val”。即属性值包含了“val”，位置不限。 并不是只有特性才能选择，自己定义的属性也能选择出来 初级伪类选择器 伪类用于向某些选择器添加特殊的效果 伪元素是指选中dom元素中的内容的、伪类是指选中整个dom root 根标签选择器“:root”选择器等同于&lt;html&gt;元素，简单点说： :root{background:orange} html{background:orange}得到的效果等同建议使用:root（xml等） 伪类、伪元素、类的选择器的元素权重比标签要大，所有如果同时设置html和根标签（root），root起作用。多使用根标签 not 否定选择器用法和jQuery 中的not类似，可以排除某些特定条件的元素 div:not([class=“demo”]) { background-color:red; } 意思为除了class为demo的div以外，所有的div的背景颜色都变红 伪类的效果可以通过添加一个实际的类来达到。伪元素的效果则需要通过添加一个实际的元素才能达到。这也是为什么他们一个称为伪类，一个称为伪元素的原因。 empty 空标签该选择器用来选择没有内容的元素、不在文档树中的元素，这里的没有内容指的是一点内容都没有，哪怕是一个空格。 以通过伪元素添加的文本内容不算内容，不占dom元素 eg: 效果： target 目标元素选择器 用来匹配被location.hash 选中的元素(即锚点元素)选择器可用于选取当前活动的目标元素 eg: 1234567891011121314151617181920212223242526272829303132&gt; &lt;style&gt;&gt; div&#123;&gt; position: relative;;&gt; width: 100px;&gt; height: 100px;&gt; color: white;&gt; &#125;&gt; ul&#123;&gt; position: fixed;&gt; left: 200px;&gt; &#125;&gt; a&#123;&gt; position: fixed; &gt; &#125;&gt; div:target&#123;&gt; color:red;&gt; &#125;&gt; &lt;/style&gt;&gt; &lt;/head&gt;&gt; &lt;body&gt;&gt; &lt;ul&gt;&gt; &lt;li&gt;&lt;a href="#1"&gt;1&lt;/a&gt;&lt;/li&gt;&gt; &lt;li&gt;&lt;a href="#2"&gt;2&lt;/a&gt;&lt;/li&gt;&gt; &lt;li&gt;&lt;a href="#3"&gt;3&lt;/a&gt;&lt;/li&gt;&gt; &lt;li&gt;&lt;a href="#4"&gt;4&lt;/a&gt;&lt;/li&gt;&gt; &lt;/ul&gt;&gt; &lt;div id="1" style="top: 30px;background-color: black"&gt;1&lt;/div&gt;&gt; &lt;div id="2" style="top:200px;background-color: green"&gt;2&lt;/div&gt;&gt; &lt;div id="3" style="top:400px;background-color: orange"&gt;3&lt;/div&gt;&gt; &lt;div id="4" style="top:600px;background-color: gray"&gt;4&lt;/div&gt;&gt; &lt;/body&gt;&gt; 效果： first-child p:first-child{} 选择属于父元素的第一个子元素的每个P元素。 eg: li:first-child{} 是指选某个元素第一个子元素是li的子元素（所以可能选出多个） last-child p:last-child{} 选择属于其父元素最后一个子元素每个 元素,可能有多个 nth-child 第x个子元素，n代表变量自然数（括号里可以填数字、even、odd） 先选出要找的元素，然后看它在父元素的位置 nth-last-child从后往前数 以上四个选择器均有弊端，即如果当前位置元素不是前面所修饰的元素，那么无效注：其父元素的第 N 个子元素，不论元素的类型。 first-of-type li:first-of-type: 选择li元素在其父元素是第一种出现的类型的li元素 last-of-type li:last-of-type{} 同理 nth-of-type li：nth-of-type(2){} ，选择属于其父元素第二个 元素的每个 元素。 nth-last-of-type 同理，只不过是从后往前数此种选择器，限制了类型，即在所修饰元素的类型下选择特定位置的元素。 only-child 唯一子元素选择器选择是独生子的子元素，即该子元素不能有兄弟元素，它的父元素只有他一个直接子元素。注意：选择的元素是独生子子元素，而非有唯一子元素的父元素。 only-of-type 如果要选择第某类特定的子元素(p) 在兄弟节点中是此类元素唯一个的话 就需要用到这个属性了 enabled 可用的元素 disabled 不可用的元素 在web的表单中，有些表单元素有可用（“enabled”）和不可用（“disabled”）状态，比如输入框，密码框，复选框等。在默认情况下，这些表单元素都处在可用状态。那么我们可以通过伪类选择器 enabled 进行选择，disabled则相反。 checked选择框 被选中状态注：checkbox, radio 的一些默认状态不可用属性进行改变，如边框颜色。 read-only 选中只读的元素eg: read-write 选中非只读的元素eg: 伪元素选择器 分类 意义 ::first-letter eg:p::first-letter选择p元素内容的首字母 ::first-line eg：p::first-line 选择p元素中内容的首行 ::before eg: p::before 在每个 元素的内容之前插入内容。 ::after eg:p::after在每个元素的内容之前插入内容。 ::selection 选择被用户选取的元素部分。 伪元素的效果是需要通过添加一个实际的元素才能达到的。 CSS3对伪元素进行了一定的调整，在以前的基础上增加了一个: 也就是现在变成了::first-letter,::first-line,::before,::after 另外还增加了一个::selection 写伪元素最好写两个：（冒号）也可以写一个： selection “::selection” 选择器是用来匹配突出显示的文本（用鼠标选择文本的时候）。浏览器默认情况下，用鼠标选择网页文本是以“蓝色的北京，白色的字体”显示的。属性：user-select: none;注：火狐下必须加-moz–moz-::selection 条件选择 E &gt; F an F element child of an E element直接子元素 E + F an F element immediately preceded by an E element 后面的紧挨着的兄弟节点 E ~ F an F element preceded by an E element后面的兄弟节点]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3新属性]]></title>
    <url>%2F2018%2F08%2F19%2Fcss3_1%E6%96%B0%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[CSS3新属性概念 CSS3是CSS2的升级版本，3只是版本号，它在CSS2.1的基础上增加了很多强大的新功能。 目前主流浏览器chrome、safari、firefox、opera、甚至360都已经支持了CSS3大部分功能了，IE10以后也开始全面支持CSS3了。 css3前缀 在编写CSS3样式时，不同的浏览器可能需要不同的前缀。它表示该CSS属性或规则尚未成为W3C标准的一部分，是浏览器的私有属性，虽然目前较新版本的浏览器都是不需要前缀的，但为了更好的向前兼容前缀还是少不了的。标准写法如表顺序，再在后面添加无前缀的： 如： 12345678910111213&lt;style&gt; .demo&#123; width:100px; height: 100px; background: red; border-radius: 50%; -webkit-border-radius:50%; -moz-border-radius:50%; -ms-border-radius:50%; -o-border-radius:50%; &#125;&lt;/style&gt;&lt;div class="demo"&gt;&lt;/div&gt; css3的属性及功能​ css3提供了更加强大且精准的选择器，提供多种背景填充方案，可以实现渐变颜色，可以改变元素的形状、角度等，可以加阴影效果，报纸布局，弹性盒子，ie6混杂模式的盒模型，新的计量单位，动画效果等等等…但是CSS3的兼容性问题同样也显得格外重要，并不是所有CSS3属性都通过了W3C标准，所以…我们需要全面的兼容性查阅手册 http://www.runoob.com/cssref/css3-browsersupport.html 兼容性参考手册 ​ border-radius border-radius:0 0 0 0; 四个参数分别对应左上角、右上角、右下角、左下角的弧度 12345678910111213141516171819202122232425262728293031&gt; &lt;style&gt;&gt; .wrapper&#123;&gt; position: relative;&gt; width: 100px;&gt; height: 100px;&gt; &#125;&gt; .left &#123;&gt; position: absolute;&gt; width: 100px;&gt; height: 50px;&gt; left: 0;&gt; border-radius: 100px 100px 0 0;&gt; background-color: red;&gt; &#125;&gt;&gt; .right &#123;&gt; position: absolute;&gt; width: 100px;&gt; height: 50px;&gt; top: 60px;&gt; left: 0px;&gt; border-radius: 0 0 100px 100px;&gt; background-color: red;&gt; &#125;&gt; &lt;/style&gt;&gt; &lt;div class="wrapper"&gt;&gt; &lt;div class="left"&gt;&lt;/div&gt;&gt; &lt;div class="right"&gt;&lt;/div&gt;&gt; &lt;/div&gt;&gt;&gt; box-shadowbox-shadow: 值类型 参数类型 X轴偏移量 0px,-50px Y轴偏移量 100px-50px; 阴影模糊半径 px 阴影扩展半径 px 阴影颜色 orange red green white 投影方式 outset（外部阴影，默认值，无需设置）、inset （将外部阴影改为内部） eg: 123.box-shadow&#123; box-shadow: 3px 0 3px 0 green,0 3px 3px 0 orange inset;&#125; 效果： text-shadow 语法:text-shadow:X-Offset Y-Offset blur color; X-Offset 表示阴影的水平偏移距离，其值为正值时阴影向右偏移，反之向左偏移； Y-Offset 是指阴影的垂直偏移距离，如果其值是正值时，阴影向下偏移，反之向上偏移； Blur 是指阴影的模糊程度，其值不能是负值，如果值越大，阴影越模糊，反之阴影越清晰，如果不需要阴影模糊可以将Blur值设置为0； Color 是指阴影的颜色，其可以使用rgba色 比如，我们可以用下面代码实现设置阴影效果。 123.text-shadow&#123;text-shadow: 0 1px 1px red;&#125; 效果： ​ 渐变的背景颜色 Gradient1）线性渐变（linear - to） 语法: linear-gradient([direction], color [percent], color [percent], …) [] 内为选填 direction角度的单位为 “deg” 也可以用to bottom, to left, to top left等的方式来表达 123456.demo&#123; margin:100px; width:300px; height:300px; background:linear-gradient(133deg,yellow 10%, green 90%); &#125; 10%是指在10%的位置开始渐变，如上图 2）径向渐变（radial - at） 语法:radial-gradient(shape at position, color [percent] , color, …) shape:放射的形状，可以为圆形circle，可以为椭圆ellipse position: 圆心位置，可以两个值，也可以一个，如果为一个时，第二个值默认center 即 50%。 值类型可以为，百分数，距离像素，也可以是方位值(left,top…); x 轴主半径 y轴次半径 123456.demo1&#123; margin:100px; width:300px; height:300px; background:radial-gradient(circle 100px at center,red 10%, green 80%,transparent 100%); &#125; 以100px为半径，剩下100%的都变成透明色 word-wrap 值 意义 normal 不换行 break-word; 换行 文字边界换行 （强制换行） 1234567891011&lt;style&gt; p&#123; width:100px; overflow:hidden; border:1px; word-wrap: break-word; &#125;&lt;/style&gt; &lt;p&gt; ljlKjlkjlkfdsjaflkjdflkasjdfksljfakls;djasdkjf;dskjfalks &lt;/p&gt; font-face字体样式 123456789&gt; @font-face&#123;&gt; &gt; font-family:”myFirstFont”;src:url('Sansation_Light.ttf'),url(‘Sansation_Light.eot') format(‘eot’)；&gt; &#125;&gt; p&#123;&gt; font-family:”myFristFont”;&gt; &#125;&gt;&gt; format: 此值指的是你自定义的字体的格式，主要用来帮助浏览器识别浏览器对@font-face的兼容问题，这里涉及到一个字体format的问题，因为不同的浏览器对字体格式支持是不一致的，浏览器自身也无法通过路径后缀来判断字体 eg: 1234567891011121314151617&lt;style&gt; p&#123; width:1000px; overflow:hidden; border:1px; word-wrap: break-word; font-family: 'Hello Beauty'; font-size: 40px; &#125; @font-face&#123; font-family: 'Hello Beauty'; src : url('./Hello Beauty Personal Use.ttf'); &#125;&lt;/style&gt;&lt;p&gt; He just not that into you.&lt;/p&gt; 效果： border-image边框应用背景 值 意义 url(xxx.png) 添加背景图片 number 为截取指定图片四周的宽度作为border的背景填充部分(截取图可按border-width 大小伸缩), number为一个数字时是复合写法最后一个属性为border-image的展示策略 stretch/repeat/round 拉伸/和四角上同等大小图片进行平铺，当边框中间区域长度不是四角图片大小的整数倍时，会被切割/铺满 eg:border-image: url(‘./border.png’) 27 round; way s tretch 很好理解就是拉伸，有多长拉多长。有多远“滚”多远 repeat (和4角上 同等大小图片进行平铺 当边框中间区域长度不是4角图片大小的整数倍时 会被切割) 铺满 (round)(4角上的图片 进行拉伸平铺 不会被切割)（共三个参数） eg:border-image: url(‘./border.png’) 27 round; background-origin背景图片起始位置 语法：background-origin ： border-box | padding-box | content-box; 参数分别表示背景图片是 从边框，还是内边距（默认值），或者是内容区域开始显示。 eg: 12345678910.demo1&#123; width:100px; height:100px; padding:50px; border: 50px solid rgba(0,0,0,0.5); background-image: url('./border-bg.png'); background-repeat:no-repeat; background-origin:content-box; /* background:radial-gradient(circle 100px at center,red 10%, green 80%,transparent 100%); */ &#125; 效果： background-clip 裁剪背景 eg: 上述代码加上 background-clip:content-box; 效果： text : background-clip : text ;从前景内容的形状（比如文字）作为裁剪区域向外裁剪，如此即可实现使用背景作为填充色之类的遮罩效果注意： webkit独有属性，且必须配合text-fill-color属性 -webkit-background-clip:text; -webkit-text-fill-color:transparent; text-fill-color:-webkit-background-clip; -webkit-background-clip: text; background-size设置背景图片的大小，以长度值或百分比显示，还可以通过cover和contain来对图片进行伸缩。 语法：background-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | cover | contain 取值说明： 取值 意义 auto(默认值) 默认值，不改变背景图片的原始高度和宽度； &lt;长度值&gt; 成对出现、如200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放； &lt;百分比&gt; 0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上； cover 用一张图片铺满整个背景，如果比例不符，则截断图 contain 尽量让背景内，存在一整张图片 background-positioneg:豆瓣评分 通过background-position来定位星数]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画的优化 客户端存储 历史记录 worker GeoLocation 多媒体]]></title>
    <url>%2F2018%2F08%2F19%2Fhtml5_3_%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[动画的优化requestAnimation概念window.requestAnimation()方法告诉浏览器，您希望执行动画并请求浏览器在下一次重绘之前调用指指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。 当你需要更新屏幕画面的时候就可以调用。在浏览器下次重绘之前执行回调函数，回调的次数通常是每秒60次但大多数浏览器通常匹配 W3C 所建议的刷新频率。在大多数浏览器里，当运行在后台标签页或者隐藏的\里时，requestAnimationFrame()会暂停调用以提升性能和电池寿命。 语法语法： 1window.requestAnimationFrame(callback); 封装： 12345678window.requestAnimationFrame = (function()&#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback)&#123; window.setTimeout(callback,1000/60); &#125; &#125;)() cancelAnimation概念取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求。 语法12window.cancelAnimationFrame(requestID);//requestID 是先前调用window.requestAnimationFrame()方法时返回的id 封装 12345678window.cancelAnimationFrame = (function()&#123; return window.CancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(id)&#123; window.clearTimeout(id); &#125; &#125;)() demo: 1234567891011121314151617181920212223242526272829window.requestAnimationFrame = (function()&#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback)&#123; window.setTimeout(callback,1000/60); &#125; &#125;)() window.cancelAnimationFrame = (function()&#123; return window.CancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(id)&#123; window.clearTimeout(id); &#125; &#125;)() //var timer; var req; function move()&#123; btn.style.left = btn.offsetLeft + 10 +'px'; if(btn.offsetLeft &gt;= 300)&#123; cancelAnimationFrame(req); btn.style.left = 300 +'px'; &#125;else&#123; req = requestAnimationFrame(move); &#125; &#125; move(); http://www.webhek.com/post/requestanimationframe.html 客户端存储localstorage、sessionstoragelocalStorage概念 localStorage是一种没有时间限制（永久存储）的数据存储，是HTML5引进的新特性，在h5之前，一直都是用cookie来存储数据的，而localStorage是存储在用户本地的浏览器上，不想cookie一样携带在http请求头部的字段里面，这样有效的节约了带宽。值得一提的是，localStorage同样也采用了同源策略对存储的容量进行了限制，一般限制为同一域名5M,不同域名的数据不能互相访问 语法123456789101112131415161718192021222324var mylocalStorage = window.localStorage; mylocalStorage.clear(); mylocalStorage.setItem('test-arry', [1, 2, 3, 4]) console.log('数组的值', mylocalStorage.getItem('test-arry')); //获取数组第一项 console.log('数组的第一项值', mylocalStorage.getItem('test-arry').split(',')[0]); var data = &#123; 'a': 1, 'b': 3 &#125; mylocalStorage.setItem('test-obj', data) console.log('直接存储对象', mylocalStorage.getItem('test-obj')); var dataStr = JSON.stringify(data); mylocalStorage.setItem('test-str', dataStr) console.log('转化后存储对象', mylocalStorage.getItem('test-str')); var data = JSON.parse(mylocalStorage.getItem('test-str')); console.log('重新解析对象', data); localStorage存储的只能是字符串的形式，当我们存储数据为引用对象的时候，会默认调用toString()方法，转化为字符串再进行存储，存储的数据项将会以逗号隔开，解析的时候需要我们分解成为数组在进行操作，对于对象，我们需要用JSON.stringfy转化存储，获取数据后再用JSON.parse转化为对象。 localStorage操作方法 方法名 含义 localStorage.length() 获取当前存储的键值对数量 localStorage.key(n) 获取第n项的键值 localStorage.setItem() 设置对应的键值对 localStorage.getItem() 获取对应键值的数据 localStorage.remove(key) 清除某个数据 localStorage.clear() 清除存储的所有数据 localStorage的适用范围 localStorage有5M的容量可以存储，所以可以存储一些不需要和服务器进行交互的数据。比如导航栏当前的状态，一些普通的数据进行缓存。甚至我们可以存储html、js或者css片段。由于现在手机端对localStorage的支持已经非常完善，有很多应用通过版本控制来存储一些不经常改动的js/css文件。减少用户请求带宽的同时，优化整个页面的加载速度。 如可以用来统计页面访问次数。 sessionstorage概念sessionStorage 是HTML5新增的一个会话存储对象，存储在本地浏览器上，用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。可以在js中调用该对象。存放数据一般在5M以下。 语法： 语法和localStorage一致，两者主要不同是存储时间和同源策略限制问题。复习时着重记住这两点 123456789101112131415161718192021222324var mysessionStorage = window.sessionStorage; mysessionStorage.clear(); mysessionStorage.setItem('test-arry', [1, 2, 3, 4]) console.log('数组的值', mysessionStorage.getItem('test-arry')); //获取数组第一项 console.log('数组的第一项值', mysessionStorage.getItem('test-arry').split(',')[0]); var data = &#123; 'a': 1, 'b': 3 &#125; mysessionStorage.setItem('test-obj', data) console.log('直接存储对象', mysessionStorage.getItem('test-obj')); var dataStr = JSON.stringify(data); mysessionStorage.setItem('test-str', dataStr) console.log('转化后存储对象', mysessionStorage.getItem('test-str')); var data = JSON.parse(mysessionStorage.getItem('test-str')); console.log('重新解析对象', data); sessionStorage操作方法 同localstorage一致，这里不再赘述。 sessionStorage适用范围适用于一些即时销毁的数据，因为当浏览器窗口关闭了，数据就不存在了。 可以用来统计当前页面下元素的访问次数。 同源策略的限制localstorage 受文档源限制 sessionstorage受文档源+窗口限制 不同的浏览器无法共享localStorage和sessionStorage中的信息，相同浏览器的不同页面可以共享相同的localStorage（页面属于相同的域名和端口），但是不同页面之间不能共享sessionstorage中的信息。这里需要注意的是，页面以及标签页仅仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。 如果存储了中文storage 则可以用 encodeURLComponent 编码 decodeURLComponent 解码 和cookie相比特性上的区别 cookie在服务器端和浏览器端来回传递数据（服务器生成，可设置失效时间；如果在浏览器端生成cookie，默认是关闭浏览器后失效）localStorage和sessionStorage不会自动把数据发送给服务器，仅仅保存在本地。cookie会在浏览器请求头或者ajax请求头中发送cookie内容 。 cookie的存放数据大小是4k左右，一个domain里最多能存放20条cookie，而storage则有5M的大小。 cookie可以设置过期日期，sessionStorage是会话级的数据，浏览器窗口关闭即清楚，localStorage是永久性的数据，一旦赋值，不管多长时间这值都是存在的，除非手动清除。 sessionStorage不跨窗口，在另外一个窗口打开sessionStorage就不存在了，它只在当前窗口有效，而cookie和localStorage都是跨窗口的，即使浏览器的窗口关闭，这两个值还是存在的。 使用场景上的区别 localStorage可以用来统计页面访问次数。 sessionStorage可以用来统计当前页面元素的点击次数。 cookie一般存储用户名密码相关信息，一般使用escape转义编码后存储。 cookie概念及语法navigator.cookieEnabled 检测是否启用了cookie 见前端网络修养章节笔记。 cookie的优点1.通过良好的编程，控制保存在cookie中的session对象的大小。2.通过加密和安全传输技术，减少cookie被破解的可能性。3.只有在cookie中存放不敏感的数据，即使被盗取也不会有很大的损失。4.控制cookie的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就 是一个过期的cookie。 cookie的缺点1.cookie的长度和数量的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB。否则会被截掉。2.安全性问题。如果cookie被人拦掉了，那个人就可以获取到所有session信息。加密的话也不起什么作用。3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务端保存一个计数器。若吧计数器保存在客户端，则起不到什么作用。 历史记录概念 window对象通过history对象提供了对浏览器历史的访问。它暴露了很多有用的方法和属性，允许你在用户浏览历史中向前和向后跳转，同时，从HTML5中提供了对了对history栈中内容的操作 history操作方法history.back() | history.forward()回退到上一个页面 |向前跳转 语法 12window.history.back();window.history.forward(); history.go(n) 跳转到指定的页面，参数n为负数时向前跳转，如当n=-1时向前跳转一个页面，当n=2时，向后跳转2个页面。 history.pushState()该方法是增添历史记录条目，但是不刷新页面，它和接下来要讲的replaceState方法在使用的时候都会和window.onpopstate配合使用 语法: 1history.pushState(state,title,url); 参数列表： 参数名 参数意义 state 一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数中。如果不需要这个对象，此处可以填null。 title： 新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。 url 新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。 从某种意义上，pushState与window.location=“#ff” 类似，二者都会在当前页面创建并激活新的历史记录。但pushState有一下几个优点： 新的URL可以是与当前URL同源的任何URL。而设置window.location 仅当你只修改了哈希值时才保持了同一个document。 如果需要，可以不改变URL，而设置window.location=”#ff”，在当前hash不是#ff的情况下，仅仅只是新建了一个新的历史记录选项 我们可以为新的历史记录选项关联任意数据。而基于hash值的方式，则必须将所有相关数据编码到一个端字符串里。 假如title参数将来会被浏览器用到，那么这个数据是可以被使用的，而哈希不可以 history.replaceState()替换当前的历史记录 ,但是不刷新页面.注意这并不会阻止其在全局浏览器历史记录中创建一个新的历史记录项。 假设一个html执行一个pushState方法，且url为‘bar1.html’ 然后再执行一个replaceState方法，url为‘bar2.html’ 那么浏览器地址栏最后显示的是bar2.html，但是浏览器不会去加载bar2，甚至不会去检查其是否存在。假设 语法： 1history.replaceState(state,title,url); history事件popstate历史记录改变时触发，调用history.pushState()或者history.replaceState()不会触发popstate事件 语法： 1234window.addEventListener('popstate',function(e)&#123; var newPage = e.state.newPage; ajax('GET','./getData.php',doData,'page='+newPage ,true) &#125;) hashchange当页面的hash值改变时触发，常用于构建单页面应用。 hash从无到有，或者从有到无。 demo： 123456789101112131415161718192021222324var item = document.getElementsByClassName('item')[0]; var header = document.getElementsByClassName('header')[0]; var page = ''; function init()&#123; history.replaceState(&#123;newPage:'one'&#125;,null,'?one'); ajax('GET','./getData.php',doData,'page=one' ,true); // method, url, callback, data, flag &#125; init(); function doData(data)&#123; console.log(data); item.innerHTML = data; &#125; header.addEventListener('click',function(e)&#123; page = e.target.getAttribute('data'); history.pushState(&#123;newPage:page&#125;,null,'?'+page); ajax('GET','./getData.php',doData,'page='+page ,true); &#125;); window.addEventListener('popstate',function(e)&#123; var newPage = e.state.newPage; ajax('GET','./getData.php',doData,'page='+newPage ,true) &#125;) 参考链接：https://www.cnblogs.com/jehorn/p/8119062.html Worker概念Worker 接口代表一个可以轻松创建的后台任务，并可以将消息发送回其创建者。创建一个工作程序只要简单的调用Worker() 构造函数，并指定一个要在工作线程中运行的脚本。 worker对象常常用来在后台帮助计算一些数据。 语法12var worker = new Worker('worker.js'); //这里的参数是指worker将要执行的脚本的url，它遵循同源策略 操作方法postMessage(n)向worker的内部作用域发送数据的方法，一次只能发送一个对象，如果想传递多个值，可以使用数组 语法 见下面的demo close()在worker作用域中调用 (在worker.js中调用） 工人自己罢工了 下面这个demo，主线程是html中script脚本，首先worker对象发送一个message（10），在worker.js收到数据后打印出来，最后worker自己关闭了，主线程中的worker对象再发送一个message（100）时，worker.js已经不再工作，故，打印结果是： worker.js 12345678onmessage = function(e)&#123; console.log(e.data); //打印了 close();&#125;function deal(data)&#123; return data * data;&#125; worker.html(作用域) 123456var worker = new Worker('worker.js'); worker.postMessage(10); worker.onmessage = function(e)&#123; worker.postMessage(100); &#125; terminate()在worker对象上调用（主进程的worker对象上的worker.terminate) 老板让工人不工作了 主进程中worker发送message（10），worker.js中收到并打印出来，在发送一个message（1010）回去，主进程收到送过来的message（10 10），打印出来，调用terminate方法，worker对象结束，主进程再发送一个message(100) ，worker.js不再为其打印。 当把worker.terminate()注释掉后： // 第一次发送message js打印 10 并返回10*10 // html 收到100 并打印 随后html发送message 100 // 100 js收到后打印100 并返回100*100 给html //10000 html 收到后打印10000 worker.html 12345678var worker = new Worker('worker.js'); worker.postMessage(10); worker.onmessage = function(e)&#123; console.log(e.data); worker.terminate(); //后面的100就不会发送过去了 worker.postMessage(100); &#125; worker.js 12345678onmessage = function(e)&#123; console.log(e.data); //打印了 postMessage(deal(e.data));&#125;function deal(data)&#123; return data * data;&#125; worker 能够产生出新的 worker，前提是这些 worker 托管于相同的源内来作为它们的父页面（一般不会这么用，因为目前不是所有浏览器都能兼容这个功能）。 此外，worker 还能够使用 XMLHttpRequest 实现网络 I/O 操作， 只不过 XMLHttpRequest 上的responseXML与 channel 两个属性值始终返回 null。 属性onerror在Worker的error事件触发并冒泡时执行 语法： 1myWorker.onerror = function() &#123; ... &#125;; 实例： 12345var myWorker = new Worker("worker.js");myWorker.onerror = function() &#123; console.log('There is an error with your worker!');&#125; 事件message其他特性 worker只是window的子集，只能实现部分功能，不能获取到window, document，所以这里不要引juery zepto。可以引入一些计算类的库。 作用域 globalWorkerScope 可以继续生成worker对象 (chrome暂时还不支持) navigator XMLHttpRequest setTimeout/serInterval GeoLocation概念navigator对象下的 方法获取地理位置信息getCurrentPosition(s,e,p) 参数意义成功的回调函数：s 失败的回调函数：e 参数options 可以定义成一个对象，其中也有一些配置参数如下： enableHighAccuracy 是否需要高精度位置默认false timeout 单位ms 请求超时时间 默认为infinity maximumAge 单位ms， 语法12345678function suc(position)&#123; console.log("success"); console.log(position); &#125; function fail()&#123; console.log("fail"); &#125; window.navigator.geolocation.getCurrentPosition(suc,fail); Geoposition对象属性意义： 属性名 属性意义 latitude 纬度 longitude 经度 altitude 海拔 accuracy 定位精准度，单位是m altitudeAccuracy 海拔精准度，单位是m heading 方向 speed 速度 PositionError 属性值 意义 code=1 用户拒绝 code=2 获取不到 code=3 连接超时 watchPosition方法则不停地取用户的地理位置信息，不停地更新用户的位置信息。位置信息过期时间 设置为0就无条件获取新的地理位置信息 默认0 语法： 1234var id = geolocation.watchPosition(fu); //用于注册监听器，在设备的地理位置发生改变的时候自动被调用。clearWatch(id);//使用 clearWatch 清除监听 devicemotion事件含义：监听加速度变化 语法： 12345window.addEventListener('devicemotion',function(e)&#123; console.log(e); item.innerHTML = e.accelerationIncludingGravity.x + '-' + e.accelerationIncludingGravity.y + '-'+ e.accelerationIncludingGravity.z; &#125;) 包含的属性 accelerationIncludingGravity 重力加速度（包括重心引力，z轴反向加了9.8，在x，y方向上的值两者相同） acceleration 重力加速度（需要陀螺仪支持） rotationRate（alpha，beta，gamma）旋转速率 interval 获取的时间间隔 以上属性均为只读属性。 摇一摇demo 代码： 123456789101112131415161718192021222324252627282930 var SHAKE_THRESHOLD = 800; //定义一个flagvar last_update = 0;var x, y, z, last_x=0, last_y=0, last_z=0;function deviceMotionHeadler(eventData) &#123; var acceleration = eventData.accelerationIncludingGravity; var curTime = new Date().getTime(); if((curTime - last_update) &gt; 300) &#123; //为了提高性能，不需每时每刻就监听加速度的变化，故设置一个时间差，每隔这个事件就看一下加速度变化了没有 var diffTime = curTime - last_update; last_update = curTime; x = acceleration.x; y = acceleration.y; z = acceleration.z; var speed = Math.abs(x + y + z - last_x - last_y - last_z) / diffTime * 10000; //通过公式，计算当下时刻加速度 与定义的flag对比 if(speed &gt; SHAKE_THRESHOLD) &#123; alert('shaked~!'); var div = document.createElement('div'); div.innerText = '11'; document.body.appendChild(div); &#125; last_x = x; last_y = y; last_z = z; &#125;&#125;window.addEventListener('devicemotion', deviceMotionHeadler, false);//整个摇一摇的原理即是通过重力加速度监听器来实现的 deviceorientation事件含义:监听设备在方向上的变化 语法： 123window.addEventListener(deviceorientation, function(event)&#123; console.log(event);&#125;); 属性介绍： 属性名 意义 alpha 表示设备沿z轴上的旋转角度，范围为0~360。 beta 表示设备在x轴上的旋转角度，范围为-180~180。它描述的是设备由前向后旋转的情况。 gamma 表示设备在y轴上的旋转角度，范围为-90~90。它描述的是设备由左向右旋转的情况。 webkitCompassHeading 与正北方向的角度差值。正北为0度，正东为90度，正南为180度，正西为270度。因为0度是正北，所以叫指北针。 webkitCompassAccuracy 指北针的精确度，表示偏差为正负多少度。一般是10。 多媒体audio音频标签语法12&lt;audio src="./src/可能否+-+木小雅.mp3" autoplay controls loop&gt;&lt;/audio&gt;&lt;!--自动播放 添加空间 循环播放--&gt; 属性controls:设置空间 autoplay:自动播放 preload：预加载，规定是否在页面加载后再录视频 ​ none:不需要加载数据 ​ metadata:元数据 诸如时长、比特率、帧大小这样的原数据，而不是媒体内容需要加载 ​ auto：浏览器应当加载它认为适量的媒体内容 loop 是否循环播放影音 currentSrc 资源链接，媒体数据的url地址 ,要在音频或者视频加载之后使用（window.onload) volume 音量 range[0,1] 通过两个button设置音量加减 12345678910111213141516171819up.onclick = function()&#123; if(audio.volume &lt;= 0.9) &#123; audio.volume += 0.1; console.log(audio.volume); &#125;else&#123; audio.volume = 1; &#125; &#125; down.onclick = function()&#123; if(audio.volume &gt;= 0.1)&#123; audio.volume -= 0.1; &#125;else&#123; audio.muted = true; &#125; &#125; muted 是否静音 true|false playbackRate 播放速率 用于指定媒体播放的速度。该属性值为1.0表示正常速度，大于1则表示”快进”，0~1之间表示”慢放”，负值表示回放。 不同浏览器实现的会有所差别，具体看浏览器实现。 currentTime 设置或返回音频/视频播放的当前位置 快进键就是基于该属性设置的 duration 返回音频/视频的时长 TimeRanges对象 played 返回已经播放的时间段 buffered返回当前已经缓冲的时间段 seekable返回用户可以跳转的时间段 这三个对象下都分别有一个length属性、一个start 一个end方法 ​ length属性表示当前的一个时间段 ​ start()返回当前时间段的起始时间点 ​ end()返回当前的结束时间点 语法： 1234audio.played.start(0);//0是指已经播放的第0段开始的时间audio.played.end(0);//已经播放了的第0段结束的时间 paused/seeking/ended paused 判断当前视频或音频是否是暂停状态 是则返回true seeking 当该属性为true时说明，视频或音频正被调节至一个新的播放点 1234audio.onseeking = function()&#123; console.log(00);&#125;//拖动音频或视频的滚动轴时，会不断的打印00 ended如果播放完媒体并且停下来，则ended为true video视频标签语法1&lt;video src="./src/wewe.mp4" width="400" height="300" controls&gt;&lt;/video&gt; 属性和audio通用。但多了一个poster属性（海报） poster： 当视频不可用时，使用一张图片替代，否则是空白 1&lt;video src="./src/wewe.mp4" width="400" height="300" controls&gt;&lt;/video&gt; 方法 play方法 pause方法 reload方法 12345678910play.click = function()&#123; audio.play(); &#125; pause.click = function()&#123; audio.pause(); &#125; reload.click = function()&#123; window.load(); &#125; 事件 play 开始播放的时候触发 pause 暂停触发 loadedmetadata 浏览器获取完媒体的元数据触发（相对loadeddata先触发） loadeddata 浏览器已经加载完当前帧数据准备播放时触发，注意ie8 123456audio.onloadedmetadata = function()&#123; console.log(2); &#125; audio.onloadeddata = function()&#123; console.log(3); &#125; ended 当前播放结束后触发 多类型标签语法： 1234&lt;audio id="music"&gt; &lt;source src="成都.mp3" type="audio/mpeg"&gt; &lt;source src="成都.ogg" type='audio/ogg"'&gt; &lt;/audio&gt; 脚本化语法1234567var audio = new Audio(); audio.src = './src/可能否+-+木小雅.mp3'; audio.controls = true; audio.loop = 'loop'; audio.preload = 'auto'; audio.autoplay = true; document.body.appendChild(audio); #####]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
